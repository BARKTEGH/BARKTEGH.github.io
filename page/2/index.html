<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 7.3.0">

  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.7.2/css/all.min.css" integrity="sha256-dABdfBfUoC8vJUBOwGVdm8L9qlMWaHTIfXt+7GnZCIo=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"yoursite.com","root":"/","images":"/images","scheme":"Gemini","darkmode":false,"version":"8.23.0","exturl":false,"sidebar":{"position":"left","width_expanded":320,"width_dual_column":240,"display":"post","padding":18,"offset":12},"hljswrap":true,"copycode":{"enable":false,"style":null},"fold":{"enable":false,"height":500},"bookmark":{"enable":false,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"duration":200,"transition":{"menu_item":"fadeInDown","post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js" defer></script>

    <meta property="og:type" content="website">
<meta property="og:title" content="三十而立的博客">
<meta property="og:url" content="http://yoursite.com/page/2/index.html">
<meta property="og:site_name" content="三十而立的博客">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="三十而立">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://yoursite.com/page/2/">


<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":true,"isPost":false,"lang":"zh-CN","comments":"","permalink":"","path":"page/2/index.html","title":""}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>三十而立的博客</title>
  








  
  <script size="300" alpha="0.6" zIndex="-1" src="https://cdnjs.cloudflare.com/ajax/libs/ribbon.js/1.0.2/ribbon.min.js" defer></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous" defer></script>
<script src="/js/utils.js" defer></script><script src="/js/motion.js" defer></script><script src="/js/sidebar.js" defer></script><script src="/js/next-boot.js" defer></script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.1/search.js" integrity="sha256-1kfA5uHPf65M5cphT2dvymhkuyHPQp5A53EGZOnOLmc=" crossorigin="anonymous" defer></script>
<script src="/js/third-party/search/local-search.js" defer></script>







  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
<link rel="alternate" href="/rss2.xml" title="三十而立的博客" type="application/rss+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <div class="column">
      <header class="header" itemscope itemtype="http://schema.org/WPHeader"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">三十而立的博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">人生苦短</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger" aria-label="搜索" role="button">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签<span class="badge">26</span></a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类<span class="badge">14</span></a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档<span class="badge">20</span></a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
      <div class="search-header">
        <span class="search-icon">
          <i class="fa fa-search"></i>
        </span>
        <div class="search-input-container">
          <input autocomplete="off" autocapitalize="off" maxlength="80"
                placeholder="搜索..." spellcheck="false"
                type="search" class="search-input">
        </div>
        <span class="popup-btn-close" role="button">
          <i class="fa fa-times-circle"></i>
        </span>
      </div>
      <div class="search-result-container">
        <div class="search-result-icon">
          <i class="fa fa-spinner fa-pulse fa-5x"></i>
        </div>
      </div>
    </div>
  </div>

</header>
        
  
  <aside class="sidebar">

    <div class="sidebar-inner sidebar-overview-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="三十而立"
      src="/uploads/image.png">
  <p class="site-author-name" itemprop="name">三十而立</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">20</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/BARKTEGH" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;BARKTEGH" rel="noopener me" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>

        </div>
      </div>
    </div>

    
  </aside>


    </div>

    <div class="main-inner index posts-expand">

    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/06/01/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BC%98%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/image.png">
      <meta itemprop="name" content="三十而立">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三十而立的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三十而立的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/06/01/%E7%A7%92%E6%9D%80%E7%B3%BB%E7%BB%9F%E7%9A%84%E4%BC%98%E5%8C%96/" class="post-title-link" itemprop="url">秒杀系统的优化</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-06-01 19:03:27" itemprop="dateCreated datePublished" datetime="2019-06-01T19:03:27+08:00">2019-06-01</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-21 23:32:32" itemprop="dateModified" datetime="2025-09-21T23:32:32+08:00">2025-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/%E9%AB%98%E5%B9%B6%E5%8F%91/" itemprop="url" rel="index"><span itemprop="name">高并发</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.6k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>6 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <hr>
<h2 id="秒杀系统简介"><a href="#秒杀系统简介" class="headerlink" title="秒杀系统简介"></a>秒杀系统简介</h2><p>秒杀场景一般会在电商网站举行一些活动或者节假日在12306网站上抢票时遇到。对于电商网站中一些稀缺或者特价商品，电商网站一般会在约定时间点对其进行限量销售，因为这些商品的特殊性，会吸引大量用户前来抢购，并且会在约定的时间点同时在秒杀页面进行抢购。</p>
<p>秒杀系统主要面临三大问题：
    </p>
<p>一、瞬时的高并发访问。抢购和普通的电商销售有所不同，普通的电商销售，流量是比较平均的，虽然有波峰波谷，但不会特别突出。而抢购是在特定时间点进行的推销活动，抢购开始前，用户不断刷新页面，以获得购买按钮；抢购开始的一瞬间，集中并发购买。 
   </p>
<p>二、数据正确性。抢购毕竟是一种购买行为，需要购买、扣减库存、支付等复杂的流程，在此过程中，要保证数据的正确性，防止超卖（卖出量超过库存）的发生。 
   </p>
<p>三、防作弊。</p>
<h2 id="秒杀系统的设计理念"><a href="#秒杀系统的设计理念" class="headerlink" title="秒杀系统的设计理念"></a>秒杀系统的设计理念</h2><p>秒杀系统的优化或者设计理念为以下几点：</p>
<p>限流： 鉴于只有少部分用户能够秒杀成功，所以要限制大部分流量，只允许少部分流量进入服务后端。</p>
<p>削峰：对于秒杀系统瞬时会有大量用户涌入，所以在抢购一开始会有很高的瞬间峰值。高峰值流量是压垮系统很重要的原因，所以如何把瞬间的高流量变成一段时间平稳的流量也是设计秒杀系统很重要的思路。实现削峰的常用的方法有利用缓存和消息中间件等技术。</p>
<p>异步处理：秒杀系统是一个高并发系统，采用异步处理模式可以极大地提高系统并发量，其实异步处理就是削峰的一种实现方式。</p>
<p>内存缓存：秒杀系统最大的瓶颈一般都是数据库读写，由于数据库读写属于磁盘IO，性能很低，如果能够把部分数据或业务逻辑转移到内存缓存，效率会有极大地提升。</p>
<p>可拓展：当然如果我们想支持更多用户，更大的并发，最好就将系统设计成弹性可拓展的，如果流量来了，拓展机器就好了。像淘宝、京东等双十一活动时会增加大量机器应对交易高峰。</p>
<h3 id="前端方案"><a href="#前端方案" class="headerlink" title="前端方案"></a>前端方案</h3><p><strong>页面静态化：</strong> 将页面上的所有静态元素全部静态化，将其交给ngix管理，以此同时采用cdn来N来抗峰值；对于动态部分采用Ajex请求动态加载数据</p>
<p><strong>静态资源优化：</strong>主要是讲多个css&#x2F;js请求合并为一个等。</p>
<p><strong>秒杀接口隐藏：</strong>在秒杀开始前一段时间才暴露出秒杀的接口（路径），同时在后端可以通过与用户id绑定生成每个用户的秒杀路径，保存在redis中，在固定时间中只允许固定的次数请求，过多的请求被拦截。这样防止使用脚本等进行大批量的请求。</p>
<p><strong>验证码：</strong>主要是为了流量削峰与筛除简单脚本。通过用户输入验证码的时间，将在某一时间的突发流量均摊到随后的一段时间，还能筛除掉一部分简单的无法识别验证码的脚本。</p>
<h3 id="后端方案"><a href="#后端方案" class="headerlink" title="后端方案"></a>后端方案</h3><p><strong>用户限流：</strong>通过对用户id绑定生成的秒杀路径，限定访问次数</p>
<p><strong>redis缓存：</strong> 将数据库内容比如秒杀商品内容详情缓存到redis，不访问数据库</p>
<p><strong>消息队列：</strong> 通过将请求缓存到消息队列，异步执行来削减同一时间到来的请求。</p>
<p><strong>CDN：</strong>内容分发网络。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。简单的来说，就是把原服务器上数据复制到其他服务器上，用户访问时，那台服务器近访问到的就是那台服务器上的数据。CDN的劣势是内容的变更生效慢，所以仅适用于“几乎不变”的资源，例如引用的js包，图片等。</p>
<h2 id="秒杀系统的具体实现"><a href="#秒杀系统的具体实现" class="headerlink" title="秒杀系统的具体实现"></a>秒杀系统的具体实现</h2><p><em>秒杀开始前：</em></p>
<p>只能看到看到秒杀商品详情，无法进入秒杀接口，直到秒杀开始前一段时间。</p>
<p>对进入秒杀商品详情页的用户将其uid与秒杀商品gid结合，生成该用户对该秒杀商品的秒杀接口路径，将其保存到redis中。</p>
<p>在秒杀商品详情页页面采用js脚本来实现倒计时与限制秒杀按钮的电机。</p>
<p><em>秒杀开始时：</em></p>
<p>服务端使用redis提前缓存秒杀商品详情，主要参数为库存数量。</p>
<p>使用redis来实现秒杀商品的预减，不直接访问数据库。当redis中的商品库存少于0，拒绝请求。这样能保证只有少量的请求能够接近数据库。</p>
<p>将抢到预减的请求放入到消息队列中，将同步转为异步执行，实现流量的再次削峰。</p>
<p>服务层从消息队列中拿出请求，进行数据库操作，实现真正的商品抢购事务，生成订单；若事务失败，回滚事务，告知用户抢购失败。若事务成功，请求用户确认订单详情，并支付。</p>
<p><strong>注意事项：</strong></p>
<p>防止买超： 需要对数据库字段进行设计，添加索引；在服务端需要对库存字段进行限制，保证不为负。</p>
<p>消息队列： 也可以使用redis来充当消息队列。</p>
<p>用户限流： 限制用户一段时间内能点击的次数</p>
<p>IP限流： 方法太过于粗暴，容易误封无辜用户，不推荐。</p>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/28/redis/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/image.png">
      <meta itemprop="name" content="三十而立">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三十而立的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三十而立的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/28/redis/" class="post-title-link" itemprop="url">Redis源码分析</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-28 20:16:20" itemprop="dateCreated datePublished" datetime="2019-05-28T20:16:20+08:00">2019-05-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-21 23:32:32" itemprop="dateModified" datetime="2025-09-21T23:32:32+08:00">2025-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Redis/" itemprop="url" rel="index"><span itemprop="name">Redis</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>26 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Redis-数据结构"><a href="#Redis-数据结构" class="headerlink" title="Redis 数据结构"></a>Redis 数据结构</h2><h3 id="简单动态字符串SDS"><a href="#简单动态字符串SDS" class="headerlink" title="简单动态字符串SDS"></a>简单动态字符串SDS</h3><hr>
<p>Redis没有直接使用传统字符串表示，而是构建一种名为简单动态字符串的抽象类型，并将SDS用作Redis默认字符串表示。</p>
<p>SDS定义如下：</p>
<pre><code>struct sdshdr&#123;

    //记录buf数组中已使用字节的数量
    //	等于SDS所保存字符串的长度
    int len；
    //记录buf数组中未使用字节数量；
    int free；
    //字节数组，用于保存字符串；
    char buf[]；

&#125;
</code></pre>
<p>SDS与C字符串区别：</p>
<ol>
<li>常数复杂度获取字符串长度</li>
<li>杜绝缓冲区溢出</li>
<li>减少修改字符串时带来的内存重分配次数</li>
<li>二进制安全</li>
<li>兼容部分C字符串函数</li>
</ol>
<h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><hr>
<p>链表节点定义：</p>
<pre><code>typedef struct listNode &#123;

    // 前置节点
    struct listNode *prev;

    // 后置节点
    struct listNode *next;

    // 节点的值
    void *value;

&#125; listNode;
</code></pre>
<p>链表节点定义：</p>
<pre><code>typedef struct list &#123;

    // 表头节点
    listNode *head;

    // 表尾节点
    listNode *tail;

    // 链表所包含的节点数量
    unsigned long len;

    // 节点值复制函数
    void *(*dup)(void *ptr);

    // 节点值释放函数
    void (*free)(void *ptr);

    // 节点值对比函数
    int (*match)(void *ptr, void *key);

&#125; list;
</code></pre>
<p>Redis 的链表实现的特性可以总结如下：</p>
<ul>
<li>双端： 链表节点带有 prev 和 next 指针， 获取某个节点的前置节点和后置节点的复杂度都是 O(1) 。</li>
<li>无环： 表头节点的 prev 指针和表尾节点的 next 指针都指向 NULL ， 对链表的访问以 NULL 为终点。</li>
<li>带表头指针和表尾指针： 通过 list 结构的 head 指针和 tail 指针， 程序获取链表的表头节点和表尾节点的复杂度为 O(1) 。</li>
<li>带链表长度计数器： 程序使用 list 结构的 len 属性来对 list 持有的链表节点进行计数， 程序获取链表中节点数量的复杂度为 O(1)。</li>
<li>多态： 链表节点使用 void* 指针来保存节点值， 并且可以通过 list 结构的 dup 、 free 、 match 三个属性为节点值设置类型特定函数， 所以链表可以用于保存各种不同类型的值。</li>
</ul>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><hr>
<p>Redis 的字典使用哈希表作为底层实现， 一个哈希表里面可以有多个哈希表节点， 而每个哈希表节点就保存了字典中的一个键值对。</p>
<p><strong>哈希表节点</strong></p>
<p>哈希表节点使用 dictEntry 结构表示， 每个 dictEntry 结构都保存着一个键值对：<br>    typedef struct dictEntry {</p>
<pre><code>    // 键
    void *key;

    // 值
    union &#123;
        void *val;
        uint64_t u64;
        int64_t s64;
    &#125; v;

    // 指向下个哈希表节点，形成链表
    struct dictEntry *next;

&#125; dictEntry;
</code></pre>
<p>key 属性保存着键值对中的键， 而 v 属性则保存着键值对中的值， 其中键值对的值可以是一个指针， 或者是一个 uint64_t 整数， 又或者是一个 int64_t 整数。</p>
<p>next 属性是指向另一个哈希表节点的指针， 这个指针可以将多个哈希值相同的键值对连接在一次， 以此来解决键冲突（collision）的问题。</p>
<p><strong>哈希表</strong></p>
<pre><code>typedef struct dictht &#123;

    // 哈希表数组
    dictEntry **table;

    // 哈希表大小
    unsigned long size;

    // 哈希表大小掩码，用于计算索引值
    // 总是等于 size - 1
    unsigned long sizemask;

    // 该哈希表已有节点的数量
    unsigned long used;

&#125; dictht;
</code></pre>
<p>table 属性是一个数组， 数组中的每个元素都是一个指向 dict.h&#x2F;dictEntry 结构的指针， 每个 dictEntry 结构保存着一个键值对。</p>
<p>size 属性记录了哈希表的大小， 也即是 table 数组的大小， 而 used 属性则记录了哈希表目前已有节点（键值对）的数量。</p>
<p>sizemask 属性的值总是等于 size - 1 ， 这个属性和哈希值一起决定一个键应该被放到 table 数组的哪个索引上面。</p>
<p>一个大小为 4 的空哈希表 （没有包含任何键值对）<br><img src="https://i.imgur.com/YzynOZ6.png"></p>
<p><strong>字典</strong></p>
<pre><code>typedef struct dict &#123;

    // 类型特定函数
    dictType *type;

    // 私有数据
    void *privdata;

    // 哈希表
    dictht ht[2];

    // rehash 索引
    // 当 rehash 不在进行时，值为 -1
    int rehashidx; /* rehashing not in progress if rehashidx == -1 */

&#125; dict;
</code></pre>
<p><img src="https://i.imgur.com/e4ZYw1P.png"></p>
<p><em>使用链地址头插法发来解决键冲突</em></p>
<p><strong>Redis rehash</strong></p>
<p>随着操作的不断执行， 哈希表保存的键值对会逐渐地增多或者减少， 为了让哈希表的负载因子（load factor）维持在一个合理的范围之内， 当哈希表保存的键值对数量太多或者太少时， 程序需要对哈希表的大小进行相应的扩展或者收缩。</p>
<p>扩展和收缩哈希表的工作可以通过执行 rehash （重新散列）操作来完成， Redis 对字典的哈希表执行 rehash 的步骤如下：</p>
<ol>
<li>为字典的 ht[1] 哈希表分配空间， 这个哈希表的空间大小取决于要执行的操作， 以及 ht[0] 当前包含的键值对数量 （也即是ht[0].used 属性的值）：<ul>
<li>如果执行的是扩展操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used * 2 的 2^n （2 的 n 次方幂）；</li>
<li>如果执行的是收缩操作， 那么 ht[1] 的大小为第一个大于等于 ht[0].used 的 2^n 。</li>
</ul>
</li>
<li>将保存在 ht[0] 中的所有键值对 rehash 到 ht[1] 上面： rehash 指的是重新计算键的哈希值和索引值， 然后将键值对放置到 ht[1] 哈希表的指定位置上。</li>
<li>当 ht[0] 包含的所有键值对都迁移到了 ht[1] 之后 （ht[0] 变为空表）， 释放 ht[0] ， 将 ht[1] 设置为 ht[0] ， 并在 ht[1] 新创建一个空白哈希表， 为下一次 rehash 做准备。</li>
</ol>
<p><strong>Redis 渐进式reshash</strong></p>
<p>因此， 为了避免 rehash 对服务器性能造成影响， 服务器不是一次性将 ht[0] 里面的所有键值对全部 rehash 到 ht[1] ， 而是分多次、渐进式地将 ht[0] 里面的键值对慢慢地 rehash 到 ht[1] 。</p>
<p>以下是哈希表渐进式 rehash 的详细步骤：</p>
<ol>
<li>为 ht[1] 分配空间， 让字典同时持有 ht[0] 和 ht[1] 两个哈希表。</li>
<li>在字典中维持一个索引计数器变量 rehashidx ， 并将它的值设置为 0 ， 表示 rehash 工作正式开始。</li>
<li>在 rehash 进行期间， 每次对字典执行添加、删除、查找或者更新操作时， 程序除了执行指定的操作以外， 还会顺带将 ht[0] 哈希表在 rehashidx 索引上的所有键值对 rehash 到 ht[1] ， 当 rehash 工作完成之后， 程序将 rehashidx 属性的值增一。</li>
<li>随着字典操作的不断执行， 最终在某个时间点上， ht[0] 的所有键值对都会被 rehash 至 ht[1] ， 这时程序将 rehashidx 属性的值设为 -1 ， 表示 rehash 操作已完成。</li>
</ol>
<p>渐进式 rehash 的好处在于它采取分而治之的方式， 将 rehash 键值对所需的计算工作均滩到对字典的每个添加、删除、查找和更新操作上， 从而避免了集中式 rehash 而带来的庞大计算量。</p>
<p><strong>哈希表的扩展与收缩</strong></p>
<p>当以下条件中的任意一个被满足时， 程序会自动开始对哈希表执行扩展操作：</p>
<ol>
<li><p>服务器目前没有在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 1 ；</p>
</li>
<li><p>服务器目前正在执行 BGSAVE 命令或者 BGREWRITEAOF 命令， 并且哈希表的负载因子大于等于 5 ；</p>
<pre><code> # 负载因子 = 哈希表已保存节点数量 / 哈希表大小
 load_factor = ht[0].used / ht[0].size
</code></pre>
</li>
</ol>
<h3 id="跳跃表"><a href="#跳跃表" class="headerlink" title="跳跃表"></a>跳跃表</h3><hr>
<p><img src="https://i.imgur.com/1Z2bIox.png"></p>
<p>Redis 的跳跃表由 redis.h&#x2F;zskiplistNode 和 redis.h&#x2F;zskiplist 两个结构定义， 其中 zskiplistNode 结构用于表示跳跃表节点， 而 zskiplist结构则用于保存跳跃表节点的相关信息， 比如节点的数量， 以及指向表头节点和表尾节点的指针， 等等。</p>
<p><img src="https://i.imgur.com/HlBGVDS.png"></p>
<p>展示了一个跳跃表示例， 位于图片最左边的是 zskiplist 结构， 该结构包含以下属性：</p>
<ul>
<li>header ：指向跳跃表的表头节点。</li>
<li>tail ：指向跳跃表的表尾节点。</li>
<li>level ：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。</li>
<li>length ：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。</li>
</ul>
<p>位于 zskiplist 结构右方的是四个 zskiplistNode 结构， 该结构包含以下属性：</p>
<ul>
<li>层（level）：节点中用 L1 、 L2 、 L3 等字样标记节点的各个层， L1 代表第一层， L2 代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</li>
<li>后退（backward）指针：节点中用 BW 字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</li>
<li>分值（score）：各个节点中的 1.0 、 2.0 和 3.0 是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</li>
<li>成员对象（obj）：各个节点中的 o1 、 o2 和 o3 是节点所保存的成员对象。</li>
</ul>
<p><strong>跳跃表节点</strong></p>
<p>跳跃表节点的实现由 redis.h&#x2F;zskiplistNode 结构定义：</p>
<pre><code>typedef struct zskiplistNode &#123;

    // 后退指针
    struct zskiplistNode *backward;

    // 分值
    double score;

    // 成员对象
    robj *obj;

    // 层
    struct zskiplistLevel &#123;

        // 前进指针
        struct zskiplistNode *forward;

        // 跨度
        unsigned int span;

    &#125; level[];

&#125; zskiplistNode;
</code></pre>
<p>与红黑树等平衡树相比，跳跃表具有以下优点：</p>
<ul>
<li>插入速度非常快速，因为不需要进行旋转等操作来维护平衡性；</li>
<li>更容易实现；</li>
<li>支持无锁操作。</li>
</ul>
<h3 id="整数集合"><a href="#整数集合" class="headerlink" title="整数集合"></a>整数集合</h3><hr>
<p>整数集合（intset）是 Redis 用于保存整数值的集合抽象数据结构， 它可以保存类型为 int16_t 、 int32_t 或者 int64_t 的整数值， 并且保证集合中不会出现重复元素。</p>
<p>每个 intset.h&#x2F;intset 结构表示一个整数集合：</p>
<pre><code>typedef struct intset &#123;

    // 编码方式
    uint32_t encoding;

    // 集合包含的元素数量
    uint32_t length;

    // 保存元素的数组
    int8_t contents[];

&#125; intset;
</code></pre>
<p>contents 数组是整数集合的底层实现： 整数集合的每个元素都是 contents 数组的一个数组项（item）， 各个项在数组中按值的大小从小到大有序地排列， 并且数组中不包含任何重复项。</p>
<p>length 属性记录了整数集合包含的元素数量， 也即是 contents 数组的长度。</p>
<p>虽然 intset 结构将 contents 属性声明为 int8_t 类型的数组， 但实际上 contents 数组并不保存任何 int8_t 类型的值 —— contents 数组的真正类型取决于 encoding 属性的值。</p>
<p><strong>升级</strong></p>
<p>每当我们要将一个新元素添加到整数集合里面， 并且新元素的类型比整数集合现有所有元素的类型都要长时， 整数集合需要先进行升级（upgrade）， 然后才能将新元素添加到整数集合里面。</p>
<p>升级整数集合并添加新元素共分为三步进行：</p>
<ul>
<li>根据新元素的类型， 扩展整数集合底层数组的空间大小， 并为新元素分配空间。</li>
<li>将底层数组现有的所有元素都转换成与新元素相同的类型， 并将类型转换后的元素放置到正确的位上， 而且在放置元素的过程中， 需要继续维持底层数组的有序性质不变。</li>
<li>将新元素添加到底层数组里面。</li>
</ul>
<p>升级的好处：</p>
<ul>
<li><p>提升灵活性：</p>
<p>  因为 C 语言是静态类型语言， 为了避免类型错误， 我们通常不会将两种不同类型的值放在同一个数据结构里面。 因为整数集合可以通过自动升级底层数组来适应新元素， 所以我们可以随意地将 int16_t 、 int32_t 或者 int64_t 类型的整数添加到集合中， 而不必担心出现类型错误， 这种做法非常灵活。</p>
</li>
<li><p>节约内存</p>
<p>  整数集合现在的做法既可以让集合能同时保存三种不同类型的值， 又可以确保升级操作只会在有需要的时候进行， 这可以尽量节省内存。</p>
</li>
</ul>
<p><strong>降级</strong></p>
<p>整数集合不支持降级操作， 一旦对数组进行了升级， 编码就会一直保持升级后的状态。</p>
<h3 id="压缩列表"><a href="#压缩列表" class="headerlink" title="压缩列表"></a>压缩列表</h3><p>压缩列表是 Redis 为了节约内存而开发的， 由一系列特殊编码的连续内存块组成的顺序型（sequential）数据结构。</p>
<p>一个压缩列表可以包含任意多个节点（entry）， 每个节点可以保存一个字节数组或者一个整数值。</p>
<p>图 7-1 展示了压缩列表的各个组成部分， 表 7-1 则记录了各个组成部分的类型、长度、以及用途。</p>
<p><img src="https://i.imgur.com/vRS8HAs.png"></p>
<p><img src="https://i.imgur.com/do4tdiY.png"></p>
<p><strong>压缩列表节点的构成</strong></p>
<p>每个压缩列表节点都由 previous_entry_length 、 encoding 、 content 三个部分组成。</p>
<p><img src="https://i.imgur.com/wck9ARV.png"></p>
<p><em><strong>previous_entry_length</strong></em></p>
<p>节点的 previous_entry_length 属性以字节为单位， 记录了压缩列表中前一个节点的长度。<br>previous_entry_length 属性的长度可以是 1 字节或者 5 字节：</p>
<ul>
<li>如果前一节点的长度小于 254 字节， 那么 previous_entry_length 属性的长度为 1 字节： 前一节点的长度就保存在这一个字节里面。</li>
<li>如果前一节点的长度大于等于 254 字节， 那么 previous_entry_length 属性的长度为 5 字节： 其中属性的第一字节会被设置为 0xFE（十进制值 254）， 而之后的四个字节则用于保存前一节点的长度。</li>
</ul>
<p><strong>encoding</strong></p>
<p>节点的 encoding 属性记录了节点的 content 属性所保存数据的类型以及长度：</p>
<ul>
<li>一字节、两字节或者五字节长， 值的最高位为 00 、 01 或者 10 的是字节数组编码： 这种编码表示节点的 content 属性保存着字节数组， 数组的长度由编码除去最高两位之后的其他位记录；</li>
<li>一字节长， 值的最高位以 11 开头的是整数编码： 这种编码表示节点的 content 属性保存着整数值， 整数值的类型和长度由编码除去最高两位之后的其他位记录；</li>
</ul>
<p><strong>content</strong></p>
<p>节点的 content 属性负责保存节点的值， 节点值可以是一个字节数组或者整数， 值的类型和长度由节点的 encoding 属性决定。</p>
<p> 其中，字节数组可以是以下三种长度的其中一种：</p>
<ul>
<li>长度小于等于 63 （2^{6}-1）字节的字节数组；</li>
<li>长度小于等于 16383 （2^{14}-1） 字节的字节数组；</li>
<li>长度小于等于 4294967295 （2^{32}-1）字节的字节数组；</li>
</ul>
<p>而整数值则可以是以下六种长度的其中一种：</p>
<ul>
<li>4 位长，介于 0 至 12 之间的无符号整数；</li>
<li>1 字节长的有符号整数；</li>
<li>3 字节长的有符号整数；</li>
<li>int16_t 类型整数；</li>
<li>int32_t 类型整数；</li>
<li>int64_t 类型整数。</li>
</ul>
<p><strong>连锁更新</strong></p>
<p> 在一个压缩列表中， 有多个连续的、长度介于 250 字节到 253 字节之间的节点 e1 至 eN。</p>
<p>因为 e1 至 eN 的所有节点的长度都小于 254 字节， 所以记录这些节点的长度只需要 1 字节长的 previous_entry_length 属性， 换句话说，e1 至 eN 的所有节点的 previous_entry_length 属性都是 1 字节长的。</p>
<p>如果我们将一个长度大于等于 254 字节的新节点 new 设置为压缩列表的表头节点， 那么 new 将成为 e1 的前置节点。</p>
<p>因为 e1 的 previous_entry_length 属性仅长 1 字节， 它没办法保存新节点 new 的长度， 所以程序将对压缩列表执行空间重分配操作， 并将e1 节点的 previous_entry_length 属性从原来的 1 字节长扩展为 5 字节长。</p>
<p>现在， 麻烦的事情来了 —— e1 原本的长度介于 250 字节至 253 字节之间， 在为 previous_entry_length 属性新增四个字节的空间之后， e1的长度就变成了介于 254 字节至 257 字节之间， 而这种长度使用 1 字节长的 previous_entry_length 属性是没办法保存的。</p>
<p>因此， 为了让 e2 的 previous_entry_length 属性可以记录下 e1 的长度， 程序需要再次对压缩列表执行空间重分配操作， 并将 e2 节点的previous_entry_length 属性从原来的 1 字节长扩展为 5 字节长。</p>
<p>正如扩展 e1 引发了对 e2 的扩展一样， 扩展 e2 也会引发对 e3 的扩展， 而扩展 e3 又会引发对 e4 的扩展……为了让每个节点的previous_entry_length 属性都符合压缩列表对节点的要求， 程序需要不断地对压缩列表执行空间重分配操作， 直到 eN 为止。</p>
<p>Redis 将这种在特殊情况下产生的连续多次空间扩展操作称之为“连锁更新”（cascade update）。</p>
<h3 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h3><hr>
<p>Redis 使用对象来表示数据库中的键和值， 每次当我们在 Redis 的数据库中新创建一个键值对时， 我们至少会创建两个对象， 一个对象用作键值对的键（键对象）， 另一个对象用作键值对的值（值对象）。</p>
<pre><code>typedef struct redisObject &#123;

    // 类型
    unsigned type:4;

    // 编码
    unsigned encoding:4;

    // 指向底层实现数据结构的指针
    void *ptr;

    // ...

&#125; robj;
</code></pre>
<p><strong>类型</strong></p>
<p>对象的 type 属性记录了对象的类型</p>
<table>
<thead>
<tr>
<th>类型常量</th>
<th>对象的名称</th>
</tr>
</thead>
<tbody><tr>
<td>REDIS_STRING</td>
<td>字符串对象</td>
</tr>
<tr>
<td>REDIS_LIST</td>
<td>列表对象</td>
</tr>
<tr>
<td>REDIS_HASH</td>
<td>哈希对象</td>
</tr>
<tr>
<td>REDIS_SET</td>
<td>集合对象</td>
</tr>
<tr>
<td>REDIS_ZSET</td>
<td>有序集合对象</td>
</tr>
</tbody></table>
<p><strong>编码</strong></p>
<p>对象的 ptr 指针指向对象的底层实现数据结构， 而这些数据结构由对象的 encoding 属性决定。通过 encoding 属性来设定对象所使用的编码， 而不是为特定类型的对象关联一种固定的编码， 极大地提升了 Redis 的灵活性和效率， 因为 Redis 可以根据不同的使用场景来为一个对象设置不同的编码， 从而优化对象在某一场景下的效率。</p>
<table>
<thead>
<tr>
<th>编码常量</th>
<th>编码所对应的底层数据结构</th>
</tr>
</thead>
<tbody><tr>
<td>REDIS_ENCODING_INT</td>
<td>long 类型的整数</td>
</tr>
<tr>
<td>REDIS_ENCODING_EMBSTR</td>
<td>embstr 编码的简单动态字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_RAW</td>
<td>简单动态字符串</td>
</tr>
<tr>
<td>REDIS_ENCODING_HT</td>
<td>字典</td>
</tr>
<tr>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>双端链表</td>
</tr>
<tr>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>压缩列表</td>
</tr>
<tr>
<td>REDIS_ENCODING_INTSET</td>
<td>整数集合</td>
</tr>
<tr>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>跳跃表和字典</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>对象所使用的底层数据结构</th>
<th>编码常量</th>
<th>OBJECT ENCODING 命令输出</th>
</tr>
</thead>
<tbody><tr>
<td>整数</td>
<td>REDIS_ENCODING_INT</td>
<td>“int”</td>
</tr>
<tr>
<td>embstr 编码的简单动态字符串（SDS）</td>
<td>REDIS_ENCODING_EMBSTR</td>
<td>“embstr”</td>
</tr>
<tr>
<td>简单动态字符串</td>
<td>REDIS_ENCODING_RAW</td>
<td>“raw”</td>
</tr>
<tr>
<td>字典</td>
<td>REDIS_ENCODING_HT</td>
<td>“hashtable”</td>
</tr>
<tr>
<td>双端链表</td>
<td>REDIS_ENCODING_LINKEDLIST</td>
<td>“linkedlist”</td>
</tr>
<tr>
<td>压缩列表</td>
<td>REDIS_ENCODING_ZIPLIST</td>
<td>“ziplist”</td>
</tr>
<tr>
<td>整数集合</td>
<td>REDIS_ENCODING_INTSET</td>
<td>“intset”</td>
</tr>
<tr>
<td>跳跃表和字典</td>
<td>REDIS_ENCODING_SKIPLIST</td>
<td>“skiplist”</td>
</tr>
</tbody></table>
<p><strong>字符串对象</strong></p>
<p>字符串对象的编码可以是 int 、 raw 或者 embstr 。</p>
<p><strong>列表对象</strong></p>
<p>列表对象的编码可以是 ziplist 或者 linkedlist 。</p>
<p>当列表对象可以同时满足以下两个条件时， 列表对象使用 ziplist 编码：</p>
<ul>
<li>列表对象保存的所有字符串元素的长度都小于 64 字节；</li>
<li>列表对象保存的元素数量小于 512 个；</li>
</ul>
<p>不能满足这两个条件的列表对象需要使用 linkedlist 编码。</p>
<p>注意以上两个条件的上限值是可以修改的， 具体请看配置文件中关于 list-max-ziplist-value 选项和 list-max-ziplist-entries 选项的说明。</p>
<p><strong>哈希对象</strong></p>
<p>哈希对象的编码可以是 ziplist 或者 hashtable 。</p>
<p>ziplist 编码的哈希对象使用压缩列表作为底层实现， 每当有新的键值对要加入到哈希对象时， 程序会先将保存了键的压缩列表节点推入到压缩列表表尾， 然后再将保存了值的压缩列表节点推入到压缩列表表尾， 因此：</p>
<ul>
<li>保存了同一键值对的两个节点总是紧挨在一起， 保存键的节点在前， 保存值的节点在后；</li>
<li>先添加到哈希对象中的键值对会被放在压缩列表的表头方向， 而后来添加到哈希对象中的键值对会被放在压缩列表的表尾方向。</li>
</ul>
<p>当哈希对象可以同时满足以下两个条件时， 哈希对象使用 ziplist 编码：</p>
<ul>
<li>哈希对象保存的所有键值对的键和值的字符串长度都小于 64 字节；</li>
<li>哈希对象保存的键值对数量小于 512 个；</li>
</ul>
<p>不能满足这两个条件的哈希对象需要使用 hashtable 编码。</p>
<p>注意这两个条件的上限值是可以修改的， 具体请看配置文件中关于 hash-max-ziplist-value 选项和 hash-max-ziplist-entries 选项的说明。</p>
<p><strong>集合对象</strong></p>
<p>集合对象的编码可以是 intset 或者 hashtable 。</p>
<p>hashtable 编码的集合对象使用字典作为底层实现， 字典的每个键都是一个字符串对象， 每个字符串对象包含了一个集合元素， 而字典的值则全部被设置为 NULL 。</p>
<p>当集合对象可以同时满足以下两个条件时， 对象使用 intset 编码：</p>
<ul>
<li>集合对象保存的所有元素都是整数值；</li>
<li>集合对象保存的元素数量不超过 512 个；</li>
</ul>
<p>不能满足这两个条件的集合对象需要使用 hashtable 编码。</p>
<p><strong>有序集合对象</strong></p>
<p>有序集合的编码可以是 ziplist 或者 skiplist 。</p>
<p>ziplist 编码的有序集合对象使用压缩列表作为底层实现， 每个集合元素使用两个紧挨在一起的压缩列表节点来保存， 第一个节点保存元素的成员（member）， 而第二个元素则保存元素的分值（score）。压缩列表内的集合元素按分值从小到大进行排序， 分值较小的元素被放置在靠近表头的方向， 而分值较大的元素则被放置在靠近表尾的方向。</p>
<p>zset 结构中的 zsl 跳跃表按分值从小到大保存了所有集合元素， 每个跳跃表节点都保存了一个集合元素： 跳跃表节点的 object 属性保存了元素的成员， 而跳跃表节点的 score 属性则保存了元素的分值。</p>
<p> Redis 选择了<strong>同时使用字典和跳跃表</strong>两种数据结构来实现有序集合。这两种数据结构都会通过指针来共享相同元素的成员和分值， 所以同时使用跳跃表和字典来保存集合元素不会产生任何重复成员或者分值， 也不会因此而浪费额外的内存。</p>
<p><img src="https://i.imgur.com/EXxjhor.png"></p>
<p>当有序集合对象可以同时满足以下两个条件时， 对象使用 ziplist 编码：</p>
<ul>
<li>有序集合保存的元素数量小于 128 个；</li>
<li>有序集合保存的所有元素成员的长度都小于 64 字节；</li>
</ul>
<p>不能满足以上两个条件的有序集合对象将使用 skiplist 编码。</p>
<h2 id="Redis数据库实现"><a href="#Redis数据库实现" class="headerlink" title="Redis数据库实现"></a>Redis数据库实现</h2><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><hr>
<p>Redis数据库服务器将所有数据库保存在服务器状态redis.h&#x2F;redisServer结构的db数据汇总</p>
<pre><code>struct redisServer&#123;
//...
// 保存服务器中所有数据库 数组
redisDb *db;
//	服务器数据库数量，默认为16
int dbnum;

&#125;;
</code></pre>
<p>Redis 是一个键值对（key-value pair）数据库服务器， 服务器中的每个数据库都由一个 redis.h&#x2F;redisDb 结构表示， 其中， redisDb 结构的dict 字典保存了数据库中的所有键值对， 我们将这个字典称为键空间（key space）：</p>
<pre><code>typedef struct redisDb &#123;

    // ...

    // 数据库键空间，保存着数据库中的所有键值对
    dict *dict;

    // ...

&#125; redisDb;
</code></pre>
<p><strong>键的生存时间</strong></p>
<ul>
<li>EXPIRE key ttl</li>
<li>PEXPIRE key ttl</li>
<li>EXPIREAT key timestamp</li>
<li>PEXPIREAT key timestamp</li>
</ul>
<p><strong>过期键删除策略</strong></p>
<ul>
<li>定时删除</li>
<li>惰性删除</li>
<li>定期删除</li>
</ul>
<p>redis服务器实际使用惰性删除和定期删除相结合来删除过期键。</p>
<p>惰性删除：对输入键进行检查，如果过期就删除键。</p>
<p>定期删除：redis服务器周期性执行activeExpireCycle函数，随机检查数据库中的键过期时间，并删除过期键。</p>
<h3 id="RDB持久化"><a href="#RDB持久化" class="headerlink" title="RDB持久化"></a>RDB持久化</h3><hr>
<h3 id="AOF持久化"><a href="#AOF持久化" class="headerlink" title="AOF持久化"></a>AOF持久化</h3><hr>
<p>　　AOF 则以协议文本的方式，将所有对数据库进行过写入的命令（及其参数）记录到 AOF<br>文件，以此达到记录数据库状态的目的。</p>
<h4 id="AOF持久化实现"><a href="#AOF持久化实现" class="headerlink" title="AOF持久化实现"></a>AOF持久化实现</h4><h5 id="命令追加"><a href="#命令追加" class="headerlink" title="命令追加"></a>命令追加</h5><p> 　　在AOF持久化功能处于打开状态时，服务器在执行完一个写命令后，或以协议格式将被执行的写命令追加到服务器的aof——buf缓冲区末尾；</p>
<pre><code>    struct redisServer&#123;
        //....
        //aof缓冲区
        sds aod_buf;
    &#125;
</code></pre>
<h5 id="AOF文件的写入与同步"><a href="#AOF文件的写入与同步" class="headerlink" title="AOF文件的写入与同步"></a>AOF文件的写入与同步</h5><p>　　因为服务器在处理文件事件时可能会执行写命令， 使得一些内容被追加到 aof_buf 缓冲区里面， 所以在服务器每次结束一个事件循环之前， 它都会调用 flushAppendOnlyFile 函数， 考虑是否需要将 aof_buf 缓冲区中的内容写入和保存到 AOF 文件里面， 这个过程可以用以下伪代码表示：</p>
<pre><code>def eventLoop():

    while True:

        # 处理文件事件，接收命令请求以及发送命令回复
        # 处理命令请求时可能会有新内容被追加到 aof_buf 缓冲区中
        processFileEvents()

        # 处理时间事件
        processTimeEvents()

        # 考虑是否要将 aof_buf 中的内容写入和保存到 AOF 文件里面
        flushAppendOnlyFile()
</code></pre>
<p>　　flushAppendOnlyFile 函数的行为由服务器配置的 appendfsync 选项的值来决定， 各个不同值产生的行为如表 TABLE_APPENDFSYNC 所示。</p>
<p><img src="https://i.imgur.com/3fjFb3a.png"></p>
<p> 　　如果用户没有主动为 appendfsync 选项设置值， 那么 appendfsync 选项的默认值为 everysec ， 关于 appendfsync 选项的更多信息， 请参考 Redis 项目附带的示例配置文件 redis.conf 。</p>
<h4 id="AOF文件载入与数据还原"><a href="#AOF文件载入与数据还原" class="headerlink" title="AOF文件载入与数据还原"></a>AOF文件载入与数据还原</h4><p>因为AOF文件包含重建数据库状态的所有写命令，所以服务器秩序重新执行AOF文件里保存的写命令。</p>
<p>Redis读取AOF文件并还原数据库状态如下：</p>
<ol>
<li>创建一个不带网络连接的为客户端</li>
<li>从AOF文件分析并读取一条写命令</li>
<li>使用客户端执行这条写命令</li>
<li>重复2,3直到AOF文件所有写命令被处理</li>
</ol>
<h4 id="AOF重写"><a href="#AOF重写" class="headerlink" title="AOF重写"></a>AOF重写</h4><p>　　因为AOF持久化是通过保存被执行的写命令来记录数据库状态，所以随着服务器运行时间流逝，AOF文件中内容会越来越多，使用AOF文件来进行数据还原所需的时间越多。实际上ＡＯＦ文件重写是通过读取服务器当前数据库状态来实现的，而不是对现有的ＡＯＦ文件进行读取分析写入。这样能将对一个键的多个写命令替换为一个写命令。</p>
<p>　　因为AOF重写函数会进行大量的写入操作，如果调用这个函数会长时间阻塞，所以redis将aof重写程序放入到子进程执行。使用子进程同时会带来一个问题：在子进程进行AOF重写期间服务器继续处理了写请求，会导致服务器当前状态与重写后的AOF文件保存的数据库状态不一致。</p>
<p>　　为了解决这个问题，redis服务器设置了一个AOF重写缓冲区，当redis服务器在重写aof阶段，执行完一个写命令会同时将这个写命令发送给AOF缓冲区和AOF重写缓冲区。在子进程完成AOF重写工作后，父进程会调用程序将AOF重写缓冲区中内容写入到新AOF文件中。 </p>
<blockquote>
<p> Redis设计与实现</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/20/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/image.png">
      <meta itemprop="name" content="三十而立">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三十而立的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三十而立的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/20/java%E7%BA%BF%E7%A8%8B%E6%B1%A0/" class="post-title-link" itemprop="url">Java线程池</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-20 19:08:16" itemprop="dateCreated datePublished" datetime="2019-05-20T19:08:16+08:00">2019-05-20</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-21 23:32:32" itemprop="dateModified" datetime="2025-09-21T23:32:32+08:00">2025-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.3k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>12 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <hr>
<h3 id="线程池的基本使用"><a href="#线程池的基本使用" class="headerlink" title="线程池的基本使用"></a>线程池的基本使用</h3><p>java中实现线程池的类为java.uitl.concurrent.ThreadPoolExecutor继承了AbstractExecutorService类。<br>AbstractExecutorService类基本方法：</p>
<p><img src="https://raw.githubusercontent.com/BARKTEGH/MarkDownPhotos/master/multiThread/AbstrascexecuteService.png"></p>
<p>AbstractExecutorService是一个抽象类，它实现了ExecutorService接口。<br>ExecutorService接口基本方法：</p>
<p><img src="https://raw.githubusercontent.com/BARKTEGH/MarkDownPhotos/master/multiThread/executeService.png"></p>
<p>ExecutorService又是继承了Executor接口。我们看一下Executor接口的实现：</p>
<pre><code>public interface Executor &#123;
    void execute(Runnable command);
&#125;
</code></pre>
<p><img src="https://raw.githubusercontent.com/BARKTEGH/MarkDownPhotos/master/multiThread/ThreadPoolExecutor.png"></p>
<hr>
<h4 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h4><p>ThreadPoolExecutor的四个构造函数：</p>
<pre><code>public class ThreadPoolExecutor extends AbstractExecutorService &#123;
    .....
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
            BlockingQueue&lt;Runnable&gt; workQueue);
 
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
            BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory);
 
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
            BlockingQueue&lt;Runnable&gt; workQueue,RejectedExecutionHandler handler);
 
    public ThreadPoolExecutor(int corePoolSize,int maximumPoolSize,long keepAliveTime,TimeUnit unit,
        BlockingQueue&lt;Runnable&gt; workQueue,ThreadFactory threadFactory,RejectedExecutionHandler handler);
    ...
&#125;
</code></pre>
<p>每个参数的含义：</p>
<ul>
<li><p><strong>corePoolSize</strong>（线程池的基本大小）：当提交一个任务到线程池时，线程池会创建一个线<br>程来执行任务，即使其他空闲的基本线程能够执行新任务也会创建线程，等到需要执行的任<br>务数大于线程池基本大小时就不再创建。如果调用了线程池的prestartAllCoreThreads()方法，<br>线程池会提前创建并启动所有基本线程。</p>
</li>
<li><p><strong>runnableTaskQueue（任务队列）</strong>：用于保存等待执行的任务的阻塞队列。可以选择以下几<br>个阻塞队列。</p>
<ul>
<li>ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按FIFO（先进先出）原<br>则对元素进行排序。</li>
<li>LinkedBlockingQueue：一个基于链表结构的阻塞队列，此队列按FIFO排序元素，吞吐量通<br>常要高于ArrayBlockingQueue。静态工厂方法Executors.newFixedThreadPool()使用了这个队列。</li>
<li>SynchronousQueue：一个不存储元素的阻塞队列。每个插入操作必须等到另一个线程调用<br>移除操作，否则插入操作一直处于阻塞状态，吞吐量通常要高于Linked-BlockingQueue，静态工<br>厂方法Executors.newCachedThreadPool使用了这个队列。</li>
<li>PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</li>
</ul>
</li>
<li><p><strong>maximumPoolSize（线程池最大数量）：</strong>线程池允许创建的最大线程数。如果队列满了，并<br>且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。值得注意的是，如<br>果使用了无界的任务队列这个参数就没什么效果。</p>
</li>
<li><p><strong>ThreadFactory</strong>：用于设置创建线程的工厂，可以通过线程工厂给每个创建出来的线程设<br>置更有意义的名字。使用开源框架guava提供的ThreadFactoryBuilder可以快速给线程池里的线<br>程设置有意义的名字，代码如下。</p>
<pre><code>  new ThreadFactoryBuilder().setNameFormat(&quot;XX-task-%d&quot;).build();
</code></pre>
</li>
<li><p><strong>RejectedExecutionHandler（饱和策略）</strong>：当队列和线程池都满了，说明线程池处于饱和状<br>态，那么必须采取一种策略处理提交的新任务。这个策略默认情况下是AbortPolicy，表示无法<br>处理新任务时抛出异常。在JDK 1.5中Java线程池框架提供了以下4种策略。</p>
<ul>
<li>AbortPolicy：直接抛出异常。</li>
<li>CallerRunsPolicy：只用调用者所在线程来运行任务</li>
<li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li>
<li>DiscardPolicy：不处理，丢弃掉。</li>
</ul>
</li>
<li><p><strong>keepAliveTime（线程活动保持时间）</strong>：线程池的工作线程空闲后，保持存活的时间。所以，<br>如果任务很多，并且每个任务执行的时间比较短，可以调大时间，提高线程的利用率。</p>
</li>
<li><p><strong>TimeUnit（线程活动保持时间的单位）</strong>：可选的单位有天（DAYS）、小时（HOURS）、分钟<br>（MINUTES）、毫秒（MILLISECONDS）、微秒（MICROSECONDS，千分之一毫秒）和纳秒（NANOSECONDS，千分之一微秒）。</p>
</li>
</ul>
<p>在java doc中，并不提倡我们直接使用ThreadPoolExecutor，而是使用Executors类中提供的几个静态方法来创建线程池：</p>
<blockquote>
<ul>
<li><p>Executors.newCachedThreadPool();        &#x2F;&#x2F;创建一个缓冲池，缓冲池容量大小Integer.MAX_VALUE</p>
</li>
<li><p>Executors.newSingleThreadExecutor();   &#x2F;&#x2F;创建容量为1的缓冲池</p>
</li>
<li><p>Executors.newFixedThreadPool(int);    &#x2F;&#x2F;创建固定容量大小的缓冲池</p>
</li>
</ul>
</blockquote>
<p>从它们的具体实现来看，它们实际上也是调用了ThreadPoolExecutor，只不过参数都已配置好了。</p>
<pre><code>//newFixedThreadPool创建的线程池corePoolSize和maximumPoolSize值是相等的，它使用的LinkedBlockingQueue；
public static ExecutorService newFixedThreadPool(int nThreads) &#123;
    return new ThreadPoolExecutor(nThreads, nThreads,
                                  0L, TimeUnit.MILLISECONDS,
                                  new LinkedBlockingQueue&lt;Runnable&gt;());
&#125;
//newSingleThreadExecutor将corePoolSize和maximumPoolSize都设置为1，也使用的LinkedBlockingQueue；
public static ExecutorService newSingleThreadExecutor() &#123;
    return new FinalizableDelegatedExecutorService
        (new ThreadPoolExecutor(1, 1,
                                0L, TimeUnit.MILLISECONDS,
                                new LinkedBlockingQueue&lt;Runnable&gt;()));
&#125;
//newCachedThreadPool将corePoolSize设置为0，将maximumPoolSize设置为Integer.MAX_VALUE，使用的SynchronousQueue，也就是说来了任务就创建线程运行，当线程空闲超过60秒，就销毁线程。
public static ExecutorService newCachedThreadPool() &#123;
    return new ThreadPoolExecutor(0, Integer.MAX_VALUE,
                                  60L, TimeUnit.SECONDS,
                                  new SynchronousQueue&lt;Runnable&gt;());
&#125;
</code></pre>
<hr>
<h4 id="线程的初始化、提交任务、容量的动态调整和关闭线程池"><a href="#线程的初始化、提交任务、容量的动态调整和关闭线程池" class="headerlink" title="线程的初始化、提交任务、容量的动态调整和关闭线程池"></a>线程的初始化、提交任务、容量的动态调整和关闭线程池</h4><p>默认情况下，创建线程池之后，线程池中是没有线程的，需要提交任务之后才会创建线程。<br>在实际中如果需要线程池创建之后立即创建线程，可以通过以下两个方法办到：</p>
<ul>
<li>prestartCoreThread()：初始化一个核心线程；</li>
<li>prestartAllCoreThreads()：初始化所有核心线程</li>
</ul>
<p>向线程池提交任务有两个方法：execute和submit。</p>
<ul>
<li><p>execute()方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功。execute()方法实际上是Executor中声明的方法，在ThreadPoolExecutor进行了具体的实现。</p>
</li>
<li><p>submit()方法用于提交需要返回值的任务。线程池会返回一个future类型的对象，通过这个<br>future对象可以判断任务是否执行成功，并且可以通过future的get()方法来获取返回值，get()方<br>法会阻塞当前线程直到任务完成，而使用get（long timeout，TimeUnit unit）方法则会阻塞当前线<br>程一段时间后立即返回，这时候有可能任务没有执行完。submit()方法是在ExecutorService中声明的方法，在AbstractExecutorService就已经有了具体的实现，在ThreadPoolExecutor中并没有对其进行重写。</p>
</li>
</ul>
<p>ThreadPoolExecutor提供了动态调整线程池容量大小的方法：</p>
<ul>
<li>setCorePoolSize()设置核心池大小</li>
<li>setMaximumPoolSize()，设置线程池最大能创建的线程数目大小</li>
</ul>
<p> 　当上述参数从小变大时，ThreadPoolExecutor进行线程赋值，还可能立即创建新的线程来执行任务。<br>关闭线程池有shutdown和shutdownNow两个方法。</p>
<p>简单使用范例：</p>
<pre><code>public class Test &#123;
     public static void main(String[] args) &#123;   
         ThreadPoolExecutor executor = new ThreadPoolExecutor(5, 10, 200, TimeUnit.MILLISECONDS,
                 new ArrayBlockingQueue&lt;Runnable&gt;(5));
          
         for(int i=0;i&lt;15;i++)&#123;
             MyTask myTask = new MyTask(i);
             executor.execute(myTask);
             System.out.println(&quot;线程池中线程数目：&quot;+executor.getPoolSize()+&quot;，队列中等待执行的任务数目：&quot;+
             executor.getQueue().size()+&quot;，已执行玩别的任务数目：&quot;+executor.getCompletedTaskCount());
         &#125;
         executor.shutdown();
     &#125;
&#125;
 
 
class MyTask implements Runnable &#123;
    private int taskNum;
     
    public MyTask(int num) &#123;
        this.taskNum = num;
    &#125;
     
    @Override
    public void run() &#123;
        System.out.println(&quot;正在执行task &quot;+taskNum);
        try &#123;
            Thread.currentThread().sleep(4000);
        &#125; catch (InterruptedException e) &#123;
            e.printStackTrace();
        &#125;
        System.out.println(&quot;task &quot;+taskNum+&quot;执行完毕&quot;);
    &#125;
&#125;
</code></pre>
<hr>
<h4 id="线程池原理分析"><a href="#线程池原理分析" class="headerlink" title="线程池原理分析"></a>线程池原理分析</h4><p>当提交一个新任务到线程池时，线程池的处理流程如下。</p>
<ul>
<li><p>1）线程池判断核心线程池里的线程是否都在执行任务。如果不是，则创建一个新的工作<br>线程来执行任务。如果核心线程池里的线程都在执行任务，则进入下个流程。</p>
</li>
<li><p>2）线程池判断工作队列是否已经满。如果工作队列没有满，则将新提交的任务存储在这<br>个工作队列里。如果工作队列满了，则进入下个流程。</p>
</li>
<li><p>3）线程池判断线程池的线程是否都处于工作状态。如果没有，则创建一个新的工作线程<br>来执行任务。如果已经满了，则交给饱和策略来处理这个任务<br><img src="/"></p>
</li>
</ul>
<p><img src="/"></p>
<p>看一下execute的源码：</p>
<pre><code>public void execute(Runnable command) &#123;
    if (command == null)
        throw new NullPointerException();
    // 如果线程数小于基本线程数，则进入addIfUnderCorePoolSize(command)，试图创建线程并执行，当正常是add..返回true，结束，无法执行返回false。
    //如果线程数大于基本线程数，进入if或者上面的add返回false
    if (poolSize &gt;= corePoolSize || !addIfUnderCorePoolSize(command)) &#123;
        // 如线程数大于等于基本线程数或线程创建失败，则将当前任务放到工作队列中。
        if (runState == RUNNING &amp;&amp; workQueue.offer(command)) &#123;
            if (runState != RUNNING || poolSize == 0)
                ensureQueuedTaskHandled(command);
    &#125;
    
    // 如果线程池不处于运行中或任务无法放入队列，并且当前线程数量小于最大允许的线程数量，
    // 则创建一个线程执行任务。
    else if (!addIfUnderMaximumPoolSize(command))
        // 抛出RejectedExecutionException异常
        reject(command); // is shutdown or saturated
    &#125;
&#125;

//当线程数低于核心池大小时执行的方法
private boolean addIfUnderCorePoolSize(Runnable firstTask) &#123;
    Thread t = null;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try &#123;
        if (poolSize &lt; corePoolSize &amp;&amp; runState == RUNNING)
            t = addThread(firstTask);        //创建线程去执行firstTask任务   
        &#125; finally &#123;
        mainLock.unlock();
    &#125;
    if (t == null)
        return false;
    t.start();
    return true;
&#125;

//用提交的任务创建了一个Worker对象，然后调用线程工厂threadFactory创建了一个新的线程t，
//然后将线程t的引用赋值给了Worker对象的成员变量thread，
//接着通过workers.add(w)将Worker对象添加到工作集当中。
private Thread addThread(Runnable firstTask) &#123;
    Worker w = new Worker(firstTask);
    Thread t = threadFactory.newThread(w);  //创建一个线程，执行任务   
    if (t != null) &#123;
        w.thread = t;            //将创建的线程的引用赋值为w的成员变量       
        workers.add(w);
        int nt = ++poolSize;     //当前线程数加1       
        if (nt &gt; largestPoolSize)
            largestPoolSize = nt;
    &#125;
    return t;
&#125;

//work类的run方法，
//首先执行的是通过构造器传进来的任务firstTask，
//在调用runTask()执行完firstTask之后，在while循环里面不断通过getTask()去取新的任务来执行，那么去哪里取呢？自然是从任务缓存队列里面去取
public void run() &#123;
    try &#123;
        Runnable task = firstTask;
        firstTask = null;
        while (task != null || (task = getTask()) != null) &#123;
            runTask(task);
            task = null;
        &#125;
    &#125; finally &#123;
        workerDone(this);
    &#125;
&#125;

//getTask是ThreadPoolExecutor类中的方法，并不是Worker类中的方法，下面是getTask方法的实现
//在getTask中，先判断当前线程池状态，如果runState大于SHUTDOWN（即为STOP或者TERMINATED），则直接返回null
 //如果runState为SHUTDOWN或者RUNNING，则从任务缓存队列取任务。

//如果当前线程池的线程数大于核心池大小corePoolSize或者允许为核心池中的线程设置空闲存活时间，则调用poll(time,timeUnit)来取任务，这个方法会等待一定的时间，如果取不到任务就返回null。

//然后判断取到的任务r是否为null，为null则通过调用workerCanExit()方法来判断当前worker是否可以退出，
Runnable getTask() &#123;
    for (;;) &#123;
        try &#123;
            int state = runState;
            if (state &gt; SHUTDOWN)
                return null;
            Runnable r;
            if (state == SHUTDOWN)  // Help drain queue
                r = workQueue.poll();
            else if (poolSize &gt; corePoolSize || allowCoreThreadTimeOut) //如果线程数大于核心池大小或者允许为核心池线程设置空闲时间，
                //则通过poll取任务，若等待一定的时间取不到任务，则返回null
                r = workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS);
            else
                r = workQueue.take();
            if (r != null)
                return r;
            if (workerCanExit()) &#123;    //如果没取到任务，即r为null，则判断当前的worker是否可以退出
                if (runState &gt;= SHUTDOWN) // Wake up others
                    interruptIdleWorkers();   //中断处于空闲状态的worker
                return null;
            &#125;
            // Else retry
        &#125; catch (InterruptedException ie) &#123;
            // On interruption, re-check runState
        &#125;
    &#125;
&#125;
//workerCanExit()的实现
//如果线程池处于STOP状态、或者任务队列已为空或者允许为核心池线程设置空闲存活时间并且线程数大于1时，允许worker退出。如果允许worker退出，则调用interruptIdleWorkers()中断处于空闲状态的worker

private boolean workerCanExit() &#123;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    boolean canExit;
    //如果runState大于等于STOP，或者任务缓存队列为空了
    //或者  允许为核心池线程设置空闲存活时间并且线程池中的线程数目大于1
    try &#123;
        canExit = runState &gt;= STOP ||
            workQueue.isEmpty() ||
            (allowCoreThreadTimeOut &amp;&amp;
             poolSize &gt; Math.max(1, corePoolSize));
    &#125; finally &#123;
        mainLock.unlock();
    &#125;
    return canExit;
&#125;

//interruptIdleWorkers()的实现
//从实现可以看出，它实际上调用的是worker的interruptIfIdle()方法
void interruptIdleWorkers() &#123;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try &#123;
        for (Worker w : workers)  //实际上调用的是worker的interruptIfIdle()方法
            w.interruptIfIdle();
    &#125; finally &#123;
        mainLock.unlock();
    &#125;
&#125;

//在worker的interruptIfIdle()方法
void interruptIfIdle() &#123;
    final ReentrantLock runLock = this.runLock;
    if (runLock.tryLock()) &#123;    //注意这里，是调用tryLock()来获取锁的，因为如果当前worker正在执行任务，锁已经被获取了，是无法获取到锁的
                                //如果成功获取了锁，说明当前worker处于空闲状态
        try &#123;
    		if (thread != Thread.currentThread())  
    ·			thread.interrupt();
        &#125; finally &#123;
            runLock.unlock();
        &#125;
    &#125;
&#125;

//addIfUnderMaximumPoolSize方法的实现
//这个方法的实现思想和addIfUnderCorePoolSize方法的实现思想非常相似，唯一的区别在于addIfUnderMaximumPoolSize方法是在线程池中的线程数达到了核心池大小并且往任务队列中添加任务失败的情况下执行的：
private boolean addIfUnderMaximumPoolSize(Runnable firstTask) &#123;
    Thread t = null;
    final ReentrantLock mainLock = this.mainLock;
    mainLock.lock();
    try &#123;
        if (poolSize &lt; maximumPoolSize &amp;&amp; runState == RUNNING)
            t = addThread(firstTask);
    &#125; finally &#123;
        mainLock.unlock();
    &#125;
    if (t == null)
        return false;
    t.start();
    return true;
&#125;

    
</code></pre>
<p>Work类实现：</p>
<pre><code>private final class Worker implements Runnable &#123;
    private final ReentrantLock runLock = new ReentrantLock();
    private Runnable firstTask;
    volatile long completedTasks;
    Thread thread;
    Worker(Runnable firstTask) &#123;
        this.firstTask = firstTask;
    &#125;
    boolean isActive() &#123;
        return runLock.isLocked();
    &#125;
    void interruptIfIdle() &#123;
        final ReentrantLock runLock = this.runLock;
        if (runLock.tryLock()) &#123;
            try &#123;
        if (thread != Thread.currentThread())
        thread.interrupt();
            &#125; finally &#123;
                runLock.unlock();
            &#125;
        &#125;
    &#125;
    void interruptNow() &#123;
        thread.interrupt();
    &#125;
 
    private void runTask(Runnable task) &#123;
        final ReentrantLock runLock = this.runLock;
        runLock.lock();
        try &#123;
            if (runState &lt; STOP &amp;&amp;
                Thread.interrupted() &amp;&amp;
                runState &gt;= STOP)
            boolean ran = false;
            beforeExecute(thread, task);   //beforeExecute方法是ThreadPoolExecutor类的一个方法，没有具体实现，用户可以根据
            //自己需要重载这个方法和后面的afterExecute方法来进行一些统计信息，比如某个任务的执行时间等           
            try &#123;
                task.run();
                ran = true;
                afterExecute(task, null);
                ++completedTasks;
            &#125; catch (RuntimeException ex) &#123;
                if (!ran)
                    afterExecute(task, ex);
                throw ex;
            &#125;
        &#125; finally &#123;
            runLock.unlock();
        &#125;
    &#125;
 
    public void run() &#123;
        try &#123;
            Runnable task = firstTask;
            firstTask = null;
            while (task != null || (task = getTask()) != null) &#123;
                runTask(task);
                task = null;
            &#125;
        &#125; finally &#123;
            workerDone(this);   //当任务队列中没有任务时，进行清理工作       
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>来源自：<a href="http://www.cnblogs.com/dolphin0520/p/3932921.html">http://www.cnblogs.com/dolphin0520/p/3932921.html</a></p>
<p>来源自：java并发编程的艺术</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/18/JAVAlock/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/image.png">
      <meta itemprop="name" content="三十而立">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三十而立的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三十而立的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/18/JAVAlock/" class="post-title-link" itemprop="url">Lock</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-18 19:06:14" itemprop="dateCreated datePublished" datetime="2019-05-18T19:06:14+08:00">2019-05-18</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-21 23:32:32" itemprop="dateModified" datetime="2025-09-21T23:32:32+08:00">2025-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/lock/" itemprop="url" rel="index"><span itemprop="name">lock</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>3.1k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <hr>
<h3 id="LOCK接口"><a href="#LOCK接口" class="headerlink" title="LOCK接口"></a>LOCK接口</h3><p>锁是用来控制多个线程访问共享资源的方式，一般来说，一个锁能够防止多个线程同时<br>访问共享资源（但是有些锁可以允许多个线程并发的访问共享资源，比如读写锁）。在Lock接<br>口出现之前，Java程序是靠synchronized关键字实现锁功能的，而Java SE 5之后，并发包中新增<br>了Lock接口（以及相关实现类）用来实现锁功能，它提供了与synchronized关键字类似的同步功<br>能，只是在使用时需要显式地获取和释放锁。虽然它缺少了（通过synchronized块或者方法所提<br>供的）隐式获取释放锁的便捷性，但是却拥有了锁获取与释放的可操作性、可中断的获取锁以<br>及超时获取锁等多种synchronized关键字所不具备的同步特性。</p>
<p><img src="https://raw.githubusercontent.com/BARKTEGH/MarkDownPhotos/master/multiThread/TIM%E6%88%AA%E5%9B%BE20181123104801.png"></p>
<p>Lock接口有三个实现类，一个是ReentrantLock,另两个是ReentrantReadWriteLock类中的两个静态内部类ReadLock和WriteLock。</p>
<ul>
<li>与互斥锁定相比，读-写锁定允许对共享数据进行更高级别的并发访问。虽然一次只有一个线程（writer 线程）可以修改共享数据，但在许多情况下，任何数量的线程可以同时读取共享数据（reader 线程）。从理论上讲，与互斥锁定相比，使用读-写锁定所允许的并发性增强将带来更大的性能提高。</li>
<li>在实践中，只有在多处理器上并且只在访问模式适用于共享数据时，才能完全实现并发性增强。——例如，某个最初用数据填充并且之后不经常对其进行<br>修改的 collection，因为经常对其进行搜索（比如搜索某种目录），所以这样的 collection 是使用读-写锁定的理想候选者。</li>
</ul>
<hr>
<h3 id="队列同步器"><a href="#队列同步器" class="headerlink" title="队列同步器"></a>队列同步器</h3><p>队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组<br>件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获<br>取线程的排队工作。</p>
<p>同步器是实现锁（也可以是任意同步组件）的关键，在锁的实现中聚合同步器，利用同步<br>器实现锁的语义。可以这样理解二者之间的关系：<strong>锁是面向使用者的，它定义了使用者与锁交<br>互的接口（比如可以允许两个线程并行访问），隐藏了实现细节；同步器面向的是锁的实现者，<br>它简化了锁的实现方式，屏蔽了同步状态管理、线程的排队、等待与唤醒等底层操作。</strong></p>
<p>同步器的主要使用方式是继承，子类通过继承同步器并实现它的抽象方法来管理同步状<br>态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3<br>个方法（getState()、setState(int newState)和compareAndSetState(int expect,int update)）来进行操作，因为它们能够保证状态的改变是安全的。子类推荐被定义为自定义同步组件的静态内部<br>类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来<br>供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获<br>取同步状态，这样就可以方便实现不同类型的同步组件（ReentrantLock、<br>ReentrantReadWriteLock和CountDownLatch等）。</p>
<h4 id="实现一个lock–通过队列同步器"><a href="#实现一个lock–通过队列同步器" class="headerlink" title="实现一个lock–通过队列同步器"></a>实现一个lock–通过队列同步器</h4><p>同步器AQS的设计是基于模板方法模式的，也就是说，<strong>使用者需要继承同步器并重写指定的<br>方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些<br>模板方法将会调用使用者重写的方法。</strong></p>
<p><img src="https://raw.githubusercontent.com/BARKTEGH/MarkDownPhotos/master/multiThread/TIM%E6%88%AA%E5%9B%BE20181123105140.png"></p>
<p><img src="https://raw.githubusercontent.com/BARKTEGH/MarkDownPhotos/master/multiThread/TIM%E6%88%AA%E5%9B%BE20181123105200.png"></p>
<p>同步器提供的模板方法基本上分为3类：独占式获取与释放同步状态、共享式获取与释放<br>同步状态和查询同步队列中的等待线程情况。自定义同步组件将使用同步器提供的模板方法<br>来实现自己的同步语义。</p>
<p>下面为自定义的一个lock锁：</p>
<pre><code>import java.util.concurrent.TimeUnit;
import java.util.concurrent.locks.AbstractQueuedSynchronizer;
import java.util.concurrent.locks.Condition;
import java.util.concurrent.locks.Lock;

public class Mutex implements Lock &#123;
    // 静态内部类，自定义同步器，随后模板方法会调用这些方法
    private static class Sync extends AbstractQueuedSynchronizer &#123;
        private static final long serialVersionUID = -4387327721959839431L;

        // 是否处于占用状态
        protected boolean isHeldExclusively() &#123;
            return getState() == 1;
        &#125;

        // 当状态为0的时候获取锁
        public boolean tryAcquire(int acquires) &#123;
            assert acquires == 1; // Otherwise unused
            if (compareAndSetState(0, 1)) &#123;
                setExclusiveOwnerThread(Thread.currentThread());
                return true;
            &#125;
            return false;
        &#125;

        // 释放锁，将状态设置为0
        protected boolean tryRelease(int releases) &#123;
            assert releases == 1; // Otherwise unused
            if (getState() == 0)
                throw new IllegalMonitorStateException();
            setExclusiveOwnerThread(null);
            setState(0);
            return true;
        &#125;

        // 返回一个Condition，每个condition都包含了一个condition队列
        Condition newCondition() &#123;
            return new ConditionObject();
        &#125;
    &#125;

    // 仅需要将操作代理到Sync上即可
    private final Sync sync = new Sync();

    public void lock() &#123;
        sync.acquire(1);
    &#125;

    public boolean tryLock() &#123;
        return sync.tryAcquire(1);
    &#125;

    public void unlock() &#123;
        sync.release(1);
    &#125;

    public Condition newCondition() &#123;
        return sync.newCondition();
    &#125;

    public boolean isLocked() &#123;
        return sync.isHeldExclusively();
    &#125;

    public boolean hasQueuedThreads() &#123;
        return sync.hasQueuedThreads();
    &#125;

    public void lockInterruptibly() throws InterruptedException &#123;
        sync.acquireInterruptibly(1);
    &#125;

    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123;
        return sync.tryAcquireNanos(1, unit.toNanos(timeout));
    &#125;
&#125;
</code></pre>
<h3 id="重入锁（ReentrantLock）"><a href="#重入锁（ReentrantLock）" class="headerlink" title="重入锁（ReentrantLock）"></a>重入锁（ReentrantLock）</h3><p>重入锁就是该锁支持一个线程对资源的重复可利用。除此之外，该锁还支持获取锁的公平与非公平选择。</p>
<p>ReentrantLock中有3个内部类，分别是Sync、FairSync和NonfairSync。</p>
<p>Sync是一个继承AQS的抽象类，使用独占锁，复写了tryRelease方法。tryAcquire方法由它的两个FairSync(公平锁)和NonfairSync(非公平锁)实现。</p>
<p>ReentrantLock的lock方法使用sync的lock方法，Sync的lock方法是个抽象方法，由公平锁和非公平锁去实现。unlock方法直接使用AQS的release方法。所以说公平锁和非公平锁的释放锁过程是一样的，不一样的是获取锁过程。</p>
<p>先看一下公平锁nonfair的lock方法：</p>
<pre><code>final void lock() &#123;
// acquire方法内部调用tryAcquire方法
// 公平锁的获取锁方法，对于没有获取到的线程，会按照队列的方式挂起线程
acquire(1);
&#125;

protected final boolean tryAcquire(int acquires) &#123;
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) &#123;
        // 公平锁这里多了一个!hasQueuedPredecessors()判断，表示是否有线程在队列里等待的时间比当前线程要长，如果有等待时间更长的线程，那么放弃获取锁
        if (!hasQueuedPredecessors() &amp;&amp;
            compareAndSetState(0, acquires)) &#123;
            setExclusiveOwnerThread(current);
            return true;
        &#125;
    &#125;
    else if (current == getExclusiveOwnerThread()) &#123;
        int nextc = c + acquires;
        if (nextc &lt; 0)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    &#125;
    return false;
&#125;
</code></pre>
<p>该方法与nonfairTryAcquire(int acquires)比较，唯一不同的位置为判断条件多了hasQueuedPredecessors()方法，即加入了同步队列中当前节点是否有前驱节点的判断，如果该<br>方法返回true，则表示有线程比当前线程更早地请求获取锁，因此需要等待前驱线程获取并释<br>放锁之后才能继续获取锁。</p>
<p>非公平锁lock方法：</p>
<pre><code>final void lock() &#123;
    // 非公平锁的获取锁
    // 跟公平锁的区别就在这里。直接对状态位state进行cas操作，成功就获取锁，这是一种抢占式的方式。不成功跟公平锁一样进入队列挂起线程
    if (compareAndSetState(0, 1))
        setExclusiveOwnerThread(Thread.currentThread());
    else
        acquire(1);
&#125;
// 调用Sync的nonfairTryAcquire方法
protected final boolean tryAcquire(int acquires) &#123;
    return nonfairTryAcquire(acquires);
&#125;

final boolean nonfairTryAcquire(int acquires) &#123;
    final Thread current = Thread.currentThread();
    int c = getState();
    if (c == 0) &#123;
        if (compareAndSetState(0, acquires)) &#123;
            setExclusiveOwnerThread(current);
            return true;
        &#125;
    &#125;
    else if (current == getExclusiveOwnerThread()) &#123;
        int nextc = c + acquires;
        if (nextc &lt; 0) // overflow
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(nextc);
        return true;
    &#125;
    return false;
&#125;
</code></pre>
<p>该方法增加了再次获取同步状态的处理逻辑：通过判断当前线程是否为获取锁的线程来<br>决定获取操作是否成功，如果是获取锁的线程再次请求，则将同步状态值进行增加并返回<br>true，表示获取同步状态成功。</p>
<p>对于unlock方法直接使用AQS的release方法。公平锁和非公平锁的释放锁过程是一样的，不一样的是获取锁过程。<br>    protected final boolean tryRelease(int releases) {<br>        int c &#x3D; getState() - releases; &#x2F;&#x2F; 释放<br>        if (Thread.currentThread() !&#x3D; getExclusiveOwnerThread()) &#x2F;&#x2F; 如果当前线程不是独占线程，直接抛出异常<br>            throw new IllegalMonitorStateException();<br>        boolean free &#x3D; false;<br>        if (c &#x3D;&#x3D; 0) { &#x2F;&#x2F; 由于是可重入锁，需要判断是否全部释放了<br>            free &#x3D; true;<br>            setExclusiveOwnerThread(null); &#x2F;&#x2F; 全部释放的话直接把独占线程设置为null<br>        }<br>        setState(c);<br>        return free;<br>    }</p>
<pre><code>// 恢复线程
public final boolean release(int arg) &#123;
    if (tryRelease(arg)) &#123;
        Node h = head;  // 恢复第一个挂起的线程
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    &#125;
    return false;
&#125;
</code></pre>
<p>ReentrantLock的默认构造函数使用的是NonfairSync，如果想使用FairSync，使用带有boolean参数的构造函数，传入true表示FairSync，否则是NonfairSync。</p>
<h3 id="读写锁-ReentrantReadWriteLock"><a href="#读写锁-ReentrantReadWriteLock" class="headerlink" title="读写锁 ReentrantReadWriteLock"></a>读写锁 ReentrantReadWriteLock</h3><p>读写锁在同一时刻可以允许多个读线程访问，但是在写线程访问时，所有的读<br>线程和其他写线程均被阻塞。读写锁维护了一对锁，一个读锁和一个写锁，通过分离读锁和写<br>锁，使得并发性相比一般的排他锁有了很大提升。</p>
<ul>
<li><p>使用范例</p>
<pre><code>  public class Cache &#123;
      static Map&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();
      static ReentrantReadWriteLock rwl = new ReentrantReadWriteLock();
      static Lock r = rwl.readLock();
      static Lock w = rwl.writeLock();
      // 获取一个key对应的value
      public static final Object get(String key) &#123;
          r.lock();
          try &#123;
              return map.get(key);
          &#125; finally &#123;
              r.unlock();
          &#125;
      &#125;
      // 设置key对应的value，并返回旧的value
      public static final Object put(String key, Object value) &#123;
          w.lock();
          try &#123;
              return map.put(key, value);
          &#125; finally &#123;
              w.unlock();
          &#125;
          &#125;// 清空所有的内容
          public static final void clear() &#123;
              w.lock();
              try &#123;
                  map.clear();
              &#125; finally &#123;
                  w.unlock();
              &#125;
      &#125;
  &#125;	
</code></pre>
</li>
<li><p>读写锁实现分析</p>
</li>
</ul>
<blockquote>
<ul>
<li>1 - 读写状态的设计</li>
</ul>
</blockquote>
<p>读写锁同样依赖自定义同步器来实现同步功能，而读写状态就是其同步器的同步状态。回想ReentrantLock中自定义同步器的实现，同步状态表示锁被一个线程重复获取的次数，而读写锁的自定义同步器需要在同步状态（一个整型变量）上维护多个读线程和一个写线程的状态，使得该状态的设计成为读写锁实现的关键。<br>如果在一个整型变量上维护多种状态，就一定需要“按位切割使用”这个变量，读写锁将变量切分成了两个部分，高16位表示读，低16位表示写。</p>
<blockquote>
<ul>
<li>2 - 写锁的获取与释放</li>
</ul>
</blockquote>
<p>ReentrantReadWriteLock的tryAcquire方法</p>
<pre><code>protected final boolean tryAcquire(int acquires) &#123;
    Thread current = Thread.currentThread();
    int c = getState();
    int w = exclusiveCount(c);
    if (c != 0) &#123;
        // 存在读锁或者当前获取线程不是已经获取写锁的线程
        if (w == 0 || current != getExclusiveOwnerThread())
        return false;
        if (w + exclusiveCount(acquires) &gt; MAX_COUNT)
        throw new Error(&quot;Maximum lock count exceeded&quot;);
        setState(c + acquires);
        return true;
    &#125;
    if (writerShouldBlock() || !compareAndSetState(c, c + acquires)) &#123;
        return false;
    &#125;
    setExclusiveOwnerThread(current);
    return true;
&#125;
</code></pre>
<p>写锁的释放与ReentrantLock的释放过程基本类似，每次释放均减少写状态，当写状态为0<br>时表示写锁已被释放，从而等待的读写线程能够继续访问读写锁，同时前次写线程的修改对<br>后续读写线程可见。</p>
<blockquote>
<ul>
<li>3- 读锁的获取的释放</li>
</ul>
</blockquote>
<p>ReentrantReadWriteLock的tryAcquireShared方法</p>
<pre><code>protected final int tryAcquireShared(int unused) &#123;
    for (;;) &#123;
        int c = getState();
        int nextc = c + (1 &lt;&lt; 16);
        if (nextc &lt; c)
            throw new Error(&quot;Maximum lock count exceeded&quot;);
        if (exclusiveCount(c) != 0 &amp;&amp; owner != Thread.currentThread())
            return -1;
        if (compareAndSetState(c, nextc))
            return 1;
    &#125;
&#125;
</code></pre>
<p>在tryAcquireShared(int unused)方法中，如果其他线程已经获取了写锁，则当前线程获取读<br>锁失败，进入等待状态。如果当前线程获取了写锁或者写锁未被获取，则当前线程（线程安全，<br>依靠CAS保证）增加读状态，成功获取读锁。<br>读锁的每次释放（线程安全的，可能有多个读线程同时释放读锁）均减少读状态，减少的<br>值是（1&lt;&lt;16）</p>
<h3 id="Condition接口"><a href="#Condition接口" class="headerlink" title="Condition接口"></a>Condition接口</h3><p><img src="https://raw.githubusercontent.com/BARKTEGH/MarkDownPhotos/master/multiThread/TIM%E6%88%AA%E5%9B%BE20181203164721.png"><br>简单使用：</p>
<pre><code>public class BoundedQueue&lt;T&gt; &#123;
    private Object[] items;
    // 添加的下标，删除的下标和数组当前
    private int addIndex, removeI
    private Lock lock = new R
    private Condition notEmpty
    private Condition notFull
    public BoundedQueue(int size)
        items = new Object[si
    &#125;
    // 添加一个元素，如果数组满，则添加线
    public void add(T t) throws I
        lock.lock();
        try &#123;
            while (count == items.length)
            notFull.await();
            items[addIndex] = t;
            if (++addIndex == items.length)
            addIndex = 0;
            ++count;
            notEmpty.signal();
        &#125; finally &#123;
            ock.unlock();
        &#125;
    &#125;
    // 由头部删除一个元素，如果数组空，则删除线程进入等待状态，直到有新添加
    @SuppressWarnings(&quot;unchecked&quot;)
    public T remove() throws InterruptedException &#123;
        lock.lock();
        try &#123;
            while (count == 0)
            notEmpty.await();
            Object x = items[removeIndex];
            if (++removeIndex == items.length)
            removeIndex = 0;
            --count;
            notFull.signal();
            return (T) x;
        &#125; finally &#123;
            lock.unlock();
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>全文来自 java并发编程的艺术</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/05/15/%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/image.png">
      <meta itemprop="name" content="三十而立">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三十而立的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三十而立的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/05/15/%E9%98%9F%E5%88%97%E5%90%8C%E6%AD%A5%E5%99%A8/" class="post-title-link" itemprop="url">队列同步器</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-05-15 19:03:20" itemprop="dateCreated datePublished" datetime="2019-05-15T19:03:20+08:00">2019-05-15</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-21 23:32:32" itemprop="dateModified" datetime="2025-09-21T23:32:32+08:00">2025-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.7k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="队列同步器"><a href="#队列同步器" class="headerlink" title="队列同步器"></a>队列同步器</h2><p>队列同步器AbstractQueuedSynchronizer（以下简称同步器），是用来构建锁或者其他同步组<br>件的基础框架，它使用了一个int成员变量表示同步状态，通过内置的FIFO队列来完成资源获<br>取线程的排队工作。</p>
<p>同步器的主要使用方式是<strong>继承</strong>，子类通过继承同步器并实现它的抽象方法来管理同步状<br>态，在抽象方法的实现过程中免不了要对同步状态进行更改，这时就需要使用同步器提供的3<br>个方法（getState()、setState(int newState)和compareAndSetState(int expect,int update)）来进行操<br>作，因为它们能够保证状态的改变是安全的。子类推荐被定义为自定义同步组件的静态内部<br>类，同步器自身没有实现任何同步接口，它仅仅是定义了若干同步状态获取和释放的方法来<br>供自定义同步组件使用，同步器既可以支持独占式地获取同步状态，也可以支持共享式地获<br>取同步状态，这样就可以方便实现不同类型的同步组件（ReentrantLock、<br>ReentrantReadWriteLock和CountDownLatch等）。</p>
<h2 id="队列同步器的接口与示例"><a href="#队列同步器的接口与示例" class="headerlink" title="队列同步器的接口与示例"></a>队列同步器的接口与示例</h2><p>同步器的设计是基于模板方法模式的，也就是说，使用者需要继承同步器并重写指定的<br>方法，随后将同步器组合在自定义同步组件的实现中，并调用同步器提供的模板方法，而这些<br>模板方法将会调用使用者重写的方法。</p>
<p><img src="https://raw.githubusercontent.com/BARKTEGH/MarkDownPhotos/master/multiThread/TIM%E6%88%AA%E5%9B%BE20181123105140.png"></p>
<p><img src="https://raw.githubusercontent.com/BARKTEGH/MarkDownPhotos/master/multiThread/TIM%E6%88%AA%E5%9B%BE20181123105200.png"></p>
<p>以下是重写同步器方法实现的一个独占锁。</p>
<pre><code>class Mutex implements Lock &#123;

    // 静态内部类，自定义同步器
    private static class Sync extends AbstractQueuedSynchronizer &#123;
            // 是否处于占用状态
            protected boolean isHeldExclusively() &#123;
                return getState() == 1;
            &#125; 

            // 当状态为0的时候获取锁
            public boolean tryAcquire(int acquires) &#123;
                if (compareAndSetState(0, 1)) &#123;
                    setExclusiveOwnerThread(Thread.currentThread());
                    return true;
                &#125;
                return false;
            &#125; 
            // 释放锁，将状态设置为0
            protected boolean tryRelease(int releases) &#123;
                if (getState() == 0) throw new  IllegalMonitorStateException();
                setExclusiveOwnerThread(null);
                setState(0);
                return true;
            &#125; 

            // 返回一个Condition，每个condition都包含了一个condition队列
            Condition newCondition() &#123; return new ConditionObject(); &#125;
    &#125; 

    // 仅需要将操作代理到Sync上即可
    private final Sync sync = new Sync();
    public void lock() &#123; sync.acquire(1); &#125;
    public boolean tryLock() &#123; return sync.tryAcquire(1); &#125;
    public void unlock() &#123; sync.release(1); &#125;
    public Condition newCondition() &#123; return sync.newCondition(); &#125;
    public boolean isLocked() &#123; return sync.isHeldExclusively(); &#125;
    public boolean hasQueuedThreads() &#123; return sync.hasQueuedThreads(); &#125;
    public void lockInterruptibly() throws InterruptedException &#123;
        sync.acquireInterruptibly(1);
    &#125; 
    public boolean tryLock(long timeout, TimeUnit unit) throws InterruptedException &#123;
        return sync.tryAcquireNanos(1, unit.toNanos(timeout));
    &#125;
&#125;
</code></pre>
<h2 id="队列同步器的实现分析"><a href="#队列同步器的实现分析" class="headerlink" title="队列同步器的实现分析"></a>队列同步器的实现分析</h2><h3 id="同步队列"><a href="#同步队列" class="headerlink" title="同步队列"></a>同步队列</h3><p>同步器依赖内部的同步队列（一个FIFO双向队列）来完成同步状态的管理，当前线程获取<br>同步状态失败时，同步器会将当前线程以及等待状态等信息构造成为一个节点（Node）并将其<br>加入同步队列，同时会阻塞当前线程，当同步状态释放时，会把首节点中的线程唤醒，使其再<br>次尝试获取同步状态。</p>
<p>节点是构成同步队列的基础。<br><img src="https://raw.githubusercontent.com/BARKTEGH/MarkDownPhotos/master/multiThread/TIM%E6%88%AA%E5%9B%BE20190614200946.png"></p>
<p>同步器拥有首节点（head）<br>和尾节点（tail），没有成功获取同步状态的线程将会成为节点加入该队列的尾部，同步队列的<br>基本结构如图示。</p>
<p><img src="https://raw.githubusercontent.com/BARKTEGH/MarkDownPhotos/master/multiThread/TIM%E6%88%AA%E5%9B%BE20190614201218.png"></p>
<p><em>同步队列在加入尾结点需要cas来保证线程安全，而设置头结点不需要。</em></p>
<h3 id="独占式同步状态获取与释放"><a href="#独占式同步状态获取与释放" class="headerlink" title="独占式同步状态获取与释放"></a>独占式同步状态获取与释放</h3><p>主要流程为：</p>
<p><img src="https://raw.githubusercontent.com/BARKTEGH/MarkDownPhotos/master/multiThread/TIM%E6%88%AA%E5%9B%BE20190614201543.png"></p>
<p>通过调用同步器的acquire(int arg)方法可以获取同步状态，该方法对中断不敏感，也就是<br>由于线程获取同步状态失败后进入同步队列中，后续对线程进行中断操作时，线程不会从同<br>步队列中移出。</p>
<pre><code>//同步器的acquire方法
public final void acquire(int arg) &#123;
    if (!tryAcquire(arg) &amp;&amp;
    acquireQueued(addWaiter(Node.EXCLUSIVE), arg))
    selfInterrupt();
&#125;
</code></pre>
<p>代码主要完成了同步状态获取、节点构造、加入同步队列以及在同步队列中自旋等<br>待的相关工作，其主要逻辑是：首先调用自定义同步器实现的tryAcquire(int arg)方法，该方法<br>保证线程安全的获取同步状态，如果同步状态获取失败，则构造同步节点（独占式<br>Node.EXCLUSIVE，同一时刻只能有一个线程成功获取同步状态）并通过addWaiter(Node node)<br>方法将该节点加入到同步队列的尾部，最后调用acquireQueued(Node node,int arg)方法，使得该<br>节点以“死循环”的方式获取同步状态。如果获取不到则阻塞节点中的线程，而被阻塞线程的<br>唤醒主要依靠前驱节点的出队或阻塞线程被中断来实现。</p>
<pre><code>//同步器的addWaiter和enq方法
private Node addWaiter(Node mode) &#123;
    Node node = new Node(Thread.currentThread(), mode);
    // 快速尝试在尾部添加
    Node pred = tail;if (pred != null) &#123;
        node.prev = pred;
        if (compareAndSetTail(pred, node)) &#123;
            pred.next = node;
            return node;
        &#125;
    &#125;
    enq(node);
    return node;
&#125;
private Node enq(final Node node) &#123;
    for (;;) &#123;
        Node t = tail;
        if (t == null) &#123; // Must initialize
            if (compareAndSetHead(new Node()))
            tail = head;
        &#125; else &#123;
            node.prev = t;
            if (compareAndSetTail(t, node)) &#123;
            t.next = node;
            return t;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>当前线程获取同步状态并执行了相应逻辑之后，就需要释放同步状态，使得后续节点能<br>够继续获取同步状态。通过调用同步器的release(int arg)方法可以释放同步状态，该方法在释<br>放了同步状态之后，会唤醒其后继节点（进而使后继节点重新尝试获取同步状态）。</p>
<pre><code>public final boolean release(int arg) &#123;
    if (tryRelease(arg)) &#123;
        Node h = head;
        if (h != null &amp;&amp; h.waitStatus != 0)
            unparkSuccessor(h);
        return true;
    &#125;
    return false;
&#125;
</code></pre>
<p>总结：在获取同步状态时，同步器维<br>护一个同步队列，获取状态失败的线程都会被加入到队列中并在队列中进行自旋；移出队列<br>（或停止自旋）的条件是前驱节点为头节点且成功获取了同步状态。在释放同步状态时，同步<br>器调用tryRelease(int arg)方法释放同步状态，然后唤醒头节点的后继节点。</p>
<h3 id="共享式同步状态获取与释放"><a href="#共享式同步状态获取与释放" class="headerlink" title="共享式同步状态获取与释放"></a>共享式同步状态获取与释放</h3><p>共享式获取与独占式获取最主要的区别在于同一时刻能否有多个线程同时获取到同步状<br>态。</p>
<p>通过调用同步器的acquireShared(int arg)方法可以共享式地获取同步状态。</p>
<pre><code>public final void acquireShared(int arg) &#123;
    if (tryAcquireShared(arg) &lt; 0)
        doAcquireShared(arg);
    &#125;
private void doAcquireShared(int arg) &#123;
    final Node node = addWaiter(Node.SHARED);
    boolean failed = true;
    try &#123;
        boolean interrupted = false;
        for (;;) &#123;
            final Node p = node.predecessor();
            if (p == head) &#123;
                int r = tryAcquireShared(arg);
                if (r &gt;= 0) &#123;
                    setHeadAndPropagate(node, r);
                    p.next = null;
                    if (interrupted)selfInterrupt();
                    failed = false;
                    return;
                &#125;
            &#125;
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp;parkAndCheckInterrupt())
                interrupted = true;
        &#125;
    &#125; finally &#123;
        if (failed) cancelAcquire(node);
    &#125;
&#125;
</code></pre>
<p>在acquireShared(int arg)方法中，同步器调用tryAcquireShared(int arg)方法尝试获取同步状<br>态，tryAcquireShared(int arg)方法返回值为int类型，当返回值大于等于0时，表示能够获取到同<br>步状态。因此，在共享式获取的自旋过程中，成功获取到同步状态并退出自旋的条件就是<br>tryAcquireShared(int arg)方法返回值大于等于0。可以看到，在doAcquireShared(int arg)方法的自<br>旋过程中，如果当前节点的前驱为头节点时，尝试获取同步状态，如果返回值大于等于0，表示<br>该次获取同步状态成功并从自旋过程中退出。</p>
<p>与独占式一样，共享式获取也需要释放同步状态，通过调用releaseShared(int arg)方法可以<br>释放同步状态。方法在释放同步状态之后，将会唤醒后续处于等待状态的节点。对于能够支持多个线<br>程同时访问的并发组件（比如Semaphore），它和独占式主要区别在于tryReleaseShared(int arg)<br>方法必须确保同步状态（或者资源数）线程安全释放，一般是通过循环和CAS来保证的，因为<br>释放同步状态的操作会同时来自多个线程。</p>
<pre><code>public final boolean releaseShared(int arg) &#123;
    if (tryReleaseShared(arg)) &#123;
        doReleaseShared();
        return true;
    &#125;
    return false;
&#125;
</code></pre>
<h3 id="独占式超时获取同步状态"><a href="#独占式超时获取同步状态" class="headerlink" title="独占式超时获取同步状态"></a>独占式超时获取同步状态</h3><p>通过调用同步器的doAcquireNanos(int arg,long nanosTimeout)方法可以超时获取同步状<br>态，即在指定的时间段内获取同步状态，如果获取到同步状态则返回true，否则，返回false。该<br>方法提供了传统Java同步操作（比如synchronized关键字）所不具备的特性。</p>
<p>超时获取同步状态过程可以被视作响应中断获取同步状态过程的“增强版”，<br>doAcquireNanos(int arg,long nanosTimeout)方法在支持响应中断的基础上，增加了超时获取的<br>特性。针对超时获取，主要需要计算出需要睡眠的时间间隔nanosTimeout，为了防止过早通知，<br>nanosTimeout计算公式为：nanosTimeout-&#x3D;now-lastTime，其中now为当前唤醒时间，lastTime为上<br>次唤醒时间，如果nanosTimeout大于0则表示超时时间未到，需要继续睡眠nanosTimeout纳秒，<br>反之，表示已经超时。</p>
<pre><code>private boolean doAcquireNanos(int arg, long nanosTimeout)throws InterruptedException &#123;
    long lastTime = System.nanoTime();
    final Node node = addWaiter(Node.EXCLUSIVE);
    boolean failed = true;
    try &#123;
        for (;;) &#123;
            final Node p = node.predecessor();
            if (p == head &amp;&amp; tryAcquire(arg)) &#123;
                setHead(node);
                p.next = null; // help GC
                failed = false;
                return true;
            &#125;
            if (nanosTimeout &lt;= 0) return false;
            if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold)
                LockSupport.parkNanos(this, nanosTimeout);
            long now = System.nanoTime();
            //计算时间，当前时间now减去睡眠之前的时间lastTime得到已经睡眠
            //的时间delta，然后被原有超时时间nanosTimeout减去，得到了
            //还应该睡眠的时间
            nanosTimeout -= now - lastTime;
            lastTime = now;
            if (Thread.interrupted())
                throw new InterruptedException();
        &#125;
    &#125; finally &#123;
        if (failed) cancelAcquire(node);
    &#125;
&#125;
</code></pre>
<p>该方法在自旋过程中，当节点的前驱节点为头节点时尝试获取同步状态，如果获取成功<br>则从该方法返回，这个过程和独占式同步获取的过程类似，但是在同步状态获取失败的处理<br>上有所不同。如果当前线程获取同步状态失败，则判断是否超时（nanosTimeout小于等于0表示<br>已经超时），如果没有超时，重新计算超时间隔nanosTimeout，然后使当前线程等待<br>nanosTimeout纳秒（当已到设置的超时时间，该线程会从LockSupport.parkNanos(Object<br>blocker,long nanos)方法返回）。</p>
<p>如果nanosTimeout小于等于spinForTimeoutThreshold（1000纳秒）时，将不会使该线程进行<br>超时等待，而是进入快速的自旋过程。原因在于，非常短的超时等待无法做到十分精确，如果<br>这时再进行超时等待，相反会让nanosTimeout的超时从整体上表现得反而不精确。因此，在超<br>时非常短的场景下，同步器会进入无条件的快速自旋。</p>
<p>独占式超时获取同步态的流程如图5所示。</p>
<p><img src="https://raw.githubusercontent.com/BARKTEGH/MarkDownPhotos/master/multiThread/TIM%E6%88%AA%E5%9B%BE20190614203038.png"></p>
<hr>
<blockquote>
<p>全文来自 Java并发编程的艺术  </p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/04/02/solr/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/image.png">
      <meta itemprop="name" content="三十而立">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三十而立的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三十而立的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/04/02/solr/" class="post-title-link" itemprop="url">solr简单使用</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-04-02 20:36:24" itemprop="dateCreated datePublished" datetime="2019-04-02T20:36:24+08:00">2019-04-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-21 23:32:32" itemprop="dateModified" datetime="2025-09-21T23:32:32+08:00">2025-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/solr/" itemprop="url" rel="index"><span itemprop="name">solr</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/solr/spring/" itemprop="url" rel="index"><span itemprop="name">spring</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>1.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>5 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="solr的安装与配置"><a href="#solr的安装与配置" class="headerlink" title="solr的安装与配置"></a>solr的安装与配置</h1><hr>
<h2 id="solr简介"><a href="#solr简介" class="headerlink" title="solr简介"></a>solr简介</h2><p>　　Solr（读作“solar”）是Apache Lucene项目的开源企业搜索平台。其主要功能包括全文检索、命中标示[1]、分面搜索、动态聚类、数据库集成，以及富文本（如Word、PDF）的处理。Solr是高度可扩展的，并提供了分布式搜索和索引复制。Solr是最流行的企业级搜索引擎，[2]Solr 4还增加了NoSQL支持。[3]</p>
<p>　　Solr是用Java编写、运行在Servlet容器（如Apache Tomcat或Jetty）的一个独立的全文搜索服务器。 Solr采用了Lucene Java搜索库为核心的全文索引和搜索，并具有类似REST的HTTP&#x2F;XML和JSON的API。 Solr强大的外部配置功能使得无需进行Java编码，便可对其进行调整以适应多种类型的应用程序。Solr有一个插件架构，以支持更多的高级定制。</p>
<h2 id="solr的安装"><a href="#solr的安装" class="headerlink" title="solr的安装"></a>solr的安装</h2><ol>
<li><p>下载solr 8.0版并解压 ，下载地址为： <a href="https://www-eu.apache.org/dist/lucene/solr/8.0.0/" title="下载地址">https://www-eu.apache.org/dist/lucene/solr/8.0.0/</a></p>
</li>
<li><p>下载并安装tomcat</p>
</li>
<li><p>将解压后solr-8.0.0\server\solr-webapp\webapp这个文件夹复制到tomcat的apache-tomcat-9.0.14\webapps文件夹下，并改名为solr（为了方便访问）</p>
</li>
<li><p>把solr下example&#x2F;lib&#x2F;ext 目录下的所有的 jar 包，添加到 solr 的工程中(\WEB-INF\lib目录下)。</p>
</li>
<li><p>在任意位置创建solr-home 目录如D:\solrhome，然后将solr-8.0.0\server\solr文件夹复制到该目录下</p>
</li>
<li><p>创建collection：在solr目录下创建文件夹firstcore（也就是集合），将\solr\configsets\sample_techproducts_configs下的conf文件复制到该目录下</p>
</li>
<li><p>关联 solr 及 solrhome。需要修改 solr 工程的 web.xml 文件。</p>
<pre><code> &lt;env-entry&gt;
    &lt;env-entry-name&gt;solr/home&lt;/env-entry-name&gt;
    &lt;env-entry-value&gt;d:\solrhome&lt;/env-entry-value&gt;
    &lt;env-entry-type&gt;java.lang.String&lt;/env-entry-type&gt;
 &lt;/env-entry&gt;
</code></pre>
</li>
<li><p>启动tomcat   apache-tomcat-9.0.14\bin\startup.bat</p>
</li>
</ol>
<h2 id="配置中文分析器IK-Analyzer"><a href="#配置中文分析器IK-Analyzer" class="headerlink" title="配置中文分析器IK Analyzer"></a>配置中文分析器IK Analyzer</h2><h3 id="下载IK-Analyzer："><a href="#下载IK-Analyzer：" class="headerlink" title="下载IK Analyzer："></a>下载IK Analyzer：</h3><p>　　　因为solr为8.0版本，网上常见的IK Analyzer版本为IKAnalyzer2012FF_u1.jar无法使用，需要下载最新版本，下载网址为：<a href="https://github.com/magese/ik-analyzer-solr7" title="IK">https://github.com/magese/ik-analyzer-solr7</a></p>
<h3 id="在solr中配置IK-Analyzer"><a href="#在solr中配置IK-Analyzer" class="headerlink" title="在solr中配置IK Analyzer"></a>在solr中配置IK Analyzer</h3><ol>
<li><p>将resources目录下的5个配置文件放入的solr的服务Jetty或Tomcat的webapp&#x2F;solr&#x2F;WEB-INF&#x2F;classes&#x2F;目录下;</p>
<pre><code> ①IKAnalyzer.cfg.xml 
 ②ext.dic 
 ③stopword.dic 
 ④ik.conf 
 ⑤dynamicdic.txt
</code></pre>
</li>
<li><p>配置的Solr的managed-schema(路径为solr\firstCore\conf)，添加ik分词器，示例如下;</p>
<pre><code> &lt;！ -  ik分词器 - &gt; 
 &lt;fieldType name =“text_ik”class =“solr.TextField”&gt; 
   &lt;analyzer type =“index”&gt; 
       &lt;tokenizer class =“org.wltea.analyzer.lucene.IKTokenizerFactory”useSmart = “false”conf =“ik.conf”/&gt; 
       &lt;filter class =“solr.LowerCaseFilterFactory”/&gt; 
   &lt;/ analyzer&gt; 
   &lt;analyzer type =“query”&gt; 
       &lt;tokenizer class =“org.wltea.analyzer.lucene.IKTokenizerFactory” useSmart =“true”conf =“ik.conf”/&gt; 
       &lt;filter class =“solr.LowerCaseFilterFactory”/&gt; 
   &lt;/ analyzer&gt; 
 &lt;/ fieldType&gt;
</code></pre>
</li>
</ol>
<h2 id="配置域"><a href="#配置域" class="headerlink" title="配置域"></a>配置域</h2><p>　　域相当于数据库的表字段，用户存放数据，因此用户根据业务需要去定义相关的Field（域），一般来说，每一种对应着一种数据，用户对同一种数据进行相同的操作。</p>
<p>　　域的常用属性：</p>
<pre><code>•	name：指定域的名称
•	type：指定域的类型
•	indexed：是否索引
•	stored：是否存储
•	required：是否必须
•	multiValued：是否多值
</code></pre>
<h3 id="域"><a href="#域" class="headerlink" title="域"></a>域</h3><p>修改solrhome的schema.xml文件,添加field</p>
<pre><code>&lt;field name=&quot;item_title&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;true&quot;/&gt;
</code></pre>
<h3 id="复制域"><a href="#复制域" class="headerlink" title="复制域"></a>复制域</h3><p>复制域的作用在于将某一个Field中的数据复制到另一个域中(可以用于多字段搜索)</p>
<pre><code>&lt;field name=&quot;item_keywords&quot; type=&quot;text_ik&quot; indexed=&quot;true&quot; stored=&quot;false&quot; multiValued=&quot;true&quot;/&gt;
&lt;copyField source=&quot;item_title&quot; dest=&quot;item_keywords&quot;/&gt;
&lt;copyField source=&quot;item_name&quot; dest=&quot;item_keywords&quot;/&gt;
</code></pre>
<h3 id="动态域"><a href="#动态域" class="headerlink" title="动态域"></a>动态域</h3><p>当我们需要动态扩充字段时，我们需要使用动态域。需要实现的效果如下：</p>
<pre><code>&lt;dynamicField name=&quot;item_spec_*&quot; type=&quot;string&quot; indexed=&quot;true&quot; stored=&quot;true&quot; /&gt;	
</code></pre>
<h1 id="Spring-Data-Solr的简单使用"><a href="#Spring-Data-Solr的简单使用" class="headerlink" title="Spring Data Solr的简单使用"></a>Spring Data Solr的简单使用</h1><h2 id="入门demo"><a href="#入门demo" class="headerlink" title="入门demo"></a>入门demo</h2><ol>
<li><p>创建maven工程，pom.xml中引入依赖</p>
<pre><code> &lt;dependencies&gt;
     &lt;dependency&gt;
         &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;
         &lt;artifactId&gt;spring-data-solr&lt;/artifactId&gt;
         &lt;version&gt;1.5.5.RELEASE&lt;/version&gt;
     &lt;/dependency&gt; 
     &lt;dependency&gt;
         &lt;groupId&gt;org.springframework&lt;/groupId&gt;
         &lt;artifactId&gt;spring-test&lt;/artifactId&gt;
         &lt;version&gt;4.2.4.RELEASE&lt;/version&gt;
     &lt;/dependency&gt;
     &lt;dependency&gt;
         &lt;groupId&gt;junit&lt;/groupId&gt;
         &lt;artifactId&gt;junit&lt;/artifactId&gt;
         &lt;version&gt;4.9&lt;/version&gt;
     &lt;/dependency&gt;
 &lt;/dependencies&gt;
</code></pre>
</li>
<li><p>在src&#x2F;main&#x2F;resources下创建  applicationContext-solr.xml</p>
<pre><code> &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
 &lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;
     xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xmlns:p=&quot;http://www.springframework.org/schema/p&quot;
     xmlns:context=&quot;http://www.springframework.org/schema/context&quot;
     xmlns:solr=&quot;http://www.springframework.org/schema/data/solr&quot;
     xsi:schemaLocation=&quot;http://www.springframework.org/schema/data/solr 
           http://www.springframework.org/schema/data/solr/spring-solr-1.0.xsd
         http://www.springframework.org/schema/beans 
         http://www.springframework.org/schema/beans/spring-beans.xsd
         http://www.springframework.org/schema/context 
         http://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;
     &lt;!-- solr服务器地址,记得加上集合名 --&gt;
     &lt;solr:solr-server id=&quot;solrServer&quot; url=&quot;http://127.0.0.1:8080/solr/firstcore&quot; /&gt;
     &lt;!-- solr模板，使用solr模板可对索引库进行CRUD的操作 --&gt;
     &lt;bean id=&quot;solrTemplate&quot; class=&quot;org.springframework.data.solr.core.SolrTemplate&quot;&gt;
         &lt;constructor-arg ref=&quot;solrServer&quot; /&gt;
     &lt;/bean&gt;
 &lt;/beans&gt;
</code></pre>
</li>
<li><p>将需要导入solr的实体类添加注解@Field</p>
<p>  如果属性与配置文件定义的域名称不一致，需要在注解中指定域名称。如同下面的title，在solr的配置文件中名为item_title, 所以要加上注解<code>@Field(&quot;item_titel&quot;)</code>,其他也一样。（）</p>
<pre><code> public class TbItem implements Serializable&#123;

     @Field
     private Long id;
 
     @Field(&quot;item_title&quot;)
     private String title;
         
     @Field(&quot;item_price&quot;)
     private BigDecimal price;
 
    
 &#125;
</code></pre>
</li>
<li><p>创建测试类TestTemplate.java</p>
<pre><code> @RunWith(SpringJUnit4ClassRunner.class)
 @ContextConfiguration(locations=&quot;classpath:applicationContext-solr.xml&quot;)
 public class TestTemplate &#123;
 
     @Autowired
     private SolrTemplate solrTemplate;

     //增加到solr索引库
     @Test
     public void testAdd()&#123;
         TbItem item=new TbItem();
         item.setId(1L);
         item.setTitle(&quot;barktegh&quot;);
         item.setPrice(new BigDecimal(2000));		
         solrTemplate.saveBean(item);
         solrTemplate.commit();
     &#125;

     //按主键查询
     @Test
     public void testFindOne()&#123;
         TbItem item = solrTemplate.getById(1, TbItem.class);
         System.out.println(item.getTitle());
     &#125;

     //循环项solr插入数据
     @Test
     public void testAddList()&#123;
         List&lt;TbItem&gt; list=new ArrayList();
         
         for(int i=0;i&lt;100;i++)&#123;
             TbItem item=new TbItem();
             item.setId(i+1L);
             item.setTitle(&quot;华为Mate&quot;+i);
             item.setPrice(new BigDecimal(2000+i));	
             list.add(item);
         &#125;
         
         solrTemplate.saveBeans(list);
         solrTemplate.commit();
     &#125;

     //分页查询
     @Test
     public void testPageQuery()&#123;
         Query query=new SimpleQuery(&quot;*:*&quot;);
         query.setOffset(20);//开始索引（默认0）
         query.setRows(20);//每页记录数(默认10)
         ScoredPage&lt;TbItem&gt; page = solrTemplate.queryForPage(query, TbItem.class);
         System.out.println(&quot;总记录数：&quot;+page.getTotalElements());
         List&lt;TbItem&gt; list = page.getContent();
         showList(list);
     &#125;	



     //条件查询
     @Test
     public void testPageQueryMutil()&#123;	
         Query query=new SimpleQuery(&quot;*:*&quot;);
         Criteria criteria=new Criteria(&quot;item_title&quot;).contains(&quot;2&quot;);
         criteria=criteria.and(&quot;item_title&quot;).contains(&quot;5&quot;);		
         query.addCriteria(criteria);
         //query.setOffset(20);//开始索引（默认0）
         //query.setRows(20);//每页记录数(默认10)
         ScoredPage&lt;TbItem&gt; page = solrTemplate.queryForPage(query, TbItem.class);
         System.out.println(&quot;总记录数：&quot;+page.getTotalElements());
         List&lt;TbItem&gt; list = page.getContent();
         showList(list);
     &#125;
     
     //删除全部数据
     @Test
     public void testDeleteAll()&#123;
         Query query=new SimpleQuery(&quot;*:*&quot;);
         solrTemplate.delete(query);
         solrTemplate.commit();
     &#125;


     //显示记录数据
     private void showList(List&lt;TbItem&gt; list)&#123;		
         for(TbItem item:list)&#123;
             System.out.println(item.getTitle() +item.getPrice());
         &#125;		
     &#125;

 &#125;
</code></pre>
</li>
<li><p>在 <a href="http://127.0.0.1:8080/solr">http://127.0.0.1:8080/solr</a> 可以查询到数据变化</p>
</li>
</ol>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/03/02/hashMap/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/image.png">
      <meta itemprop="name" content="三十而立">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三十而立的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三十而立的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/03/02/hashMap/" class="post-title-link" itemprop="url">HashMap详解</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-03-02 19:06:20" itemprop="dateCreated datePublished" datetime="2019-03-02T19:06:20+08:00">2019-03-02</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-21 23:32:32" itemprop="dateModified" datetime="2025-09-21T23:32:32+08:00">2025-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.9k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>11 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h1 id="HashMap介绍"><a href="#HashMap介绍" class="headerlink" title="HashMap介绍"></a>HashMap介绍</h1><hr>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HashMap是一个经典的key-value结构，是线程不安全的。如果要使用线程安全的hashMap可以使用并发包里的ConcurrentHashMap。<br>jdk在1.7和1.8的具体实现稍有不同。</p>
<h2 id="HaspMap在1-7的实现"><a href="#HaspMap在1-7的实现" class="headerlink" title="HaspMap在1.7的实现"></a>HaspMap在1.7的实现</h2><h3 id="基本数据结构和变量："><a href="#基本数据结构和变量：" class="headerlink" title="基本数据结构和变量："></a>基本数据结构和变量：</h3><p><img src="https://i.imgur.com/qJFRT7H.jpg"></p>
<p>hashmap的内部数据结构是一个Entry数组<code>transient Node&lt;K,V&gt;[] table</code>（被关键citransient修饰是为了序列化时只用序列化已使用的数据）。</p>
<p>其中Entry是一个内部类，源码如下：</p>
<pre><code>static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;
    final int hash;
    final K key;
    V value;
    Entry&lt;K,V&gt; next;

    Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123;
        this.hash = hash;
        this.key = key;
        this.value = value;
        this.next = next;
    &#125;

    public final K getKey()        &#123; return key; &#125;
    public final V getValue()      &#123; return value; &#125;
    public final String toString() &#123; return key + &quot;=&quot; + value; &#125;

    public final int hashCode() &#123;
        return Objects.hashCode(key) ^ Objects.hashCode(value);
    &#125;

    public final V setValue(V newValue) &#123;
        V oldValue = value;
        value = newValue;
        return oldValue;
    &#125;

    public final boolean equals(Object o) &#123;
        if (o == this)
            return true;
        if (o instanceof Map.Entry) &#123;
            Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;
            if (Objects.equals(key, e.getKey()) &amp;&amp;
                Objects.equals(value, e.getValue()))
                return true;
        &#125;
        return false;
    &#125;
&#125;
</code></pre>
<p>Entry主要有四个成员变量：	</p>
<ul>
<li>key就是键</li>
<li>value 是值</li>
<li>hash存放当前key的hashcode</li>
<li>next用于实现链表</li>
</ul>
<p>HashMap还有一些核心变量如下：</p>
<ol>
<li><p>static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; </p>
<p> 初始化桶的大小，默认为16。选择2的n次方是为了在扩容是计算hashcode将取模运算转为位运算。</p>
<pre><code> static final int hash(Object key) &#123;
     int h;
     return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);
 &#125;
</code></pre>
</li>
<li><p>static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;</p>
<p> 桶最大值</p>
</li>
<li><p>static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;</p>
<p> 默认装载因子0.75</p>
</li>
<li><p>transient int size;</p>
<p> Map存放数量的大小</p>
</li>
<li><p>int threshold;</p>
<p> 桶大小，可在初始化时显式指定</p>
</li>
<li><p>final float loadFactor;</p>
<p> 装载因子，可在初始化时显式指定。<br> 其中当map的数量达到threshold*loadFactor时，就需要对map就行扩容。</p>
</li>
</ol>
<h3 id="put方法"><a href="#put方法" class="headerlink" title="put方法"></a>put方法</h3><p>HashMap存放数据1.7源码如下：</p>
<pre><code>public V put(K key, V value) &#123;
    if (table == EMPTY_TABLE) &#123;
        inflateTable(threshold);
    &#125;
    if (key == null)
        return putForNullKey(value);
    int hash = hash(key);
    int i = indexFor(hash, table.length);
    for (Entry&lt;K,V&gt; e = table[i]; e != null; e = e.next) &#123;
        Object k;
        if (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;
            V oldValue = e.value;
            e.value = value;
            e.recordAccess(this);
            return oldValue;
        &#125;
    &#125;
    modCount++;
    addEntry(hash, key, value, i);
    return null;
&#125;
</code></pre>
<p>流程如下：</p>
<ol>
<li><p>判断当前数组是否需要初始化。</p>
</li>
<li><p>如果 key 为空，则 put 一个空值进去。</p>
</li>
<li><p>根据 key 计算出 hashcode。</p>
</li>
<li><p>根据计算出的 hashcode 定位出所在桶。</p>
</li>
<li><p>如果桶是一个链表则需要遍历判断里面的 hashcode、key 是否和传入 key 相等，如果相等则进行覆盖，并返回原来的值。</p>
</li>
<li><p>如果桶是空的或者没有找到key，说明当前位置没有数据存入；新增一个 Entry 对象写入当前位置。</p>
<pre><code> void addEntry(int hash, K key, V value, int bucketIndex) &#123;
     if ((size &gt;= threshold) &amp;&amp; (null != table[bucketIndex])) &#123;
         resize(2 * table.length);
         hash = (null != key) ? hash(key) : 0;
         bucketIndex = indexFor(hash, table.length);
     &#125;
     createEntry(hash, key, value, bucketIndex);
 &#125;
 void createEntry(int hash, K key, V value, int bucketIndex) &#123;
     Entry&lt;K,V&gt; e = table[bucketIndex];
     table[bucketIndex] = new Entry&lt;&gt;(hash, key, value, e);
     size++;
 &#125;
</code></pre>
</li>
</ol>
<h3 id="get方法"><a href="#get方法" class="headerlink" title="get方法"></a>get方法</h3><p>HashMap获取数据1.7源码如下：</p>
<pre><code>public V get(Object key) &#123;
    if (key == null)
        return getForNullKey();
    Entry&lt;K,V&gt; entry = getEntry(key);
    return null == entry ? null : entry.getValue();
&#125;
final Entry&lt;K,V&gt; getEntry(Object key) &#123;
    if (size == 0) &#123;
        return null;
    &#125;
    int hash = (key == null) ? 0 : hash(key);
    for (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];
         e != null;
         e = e.next) &#123;
        Object k;
        if (e.hash == hash &amp;&amp;
            ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
            return e;
    &#125;
    return null;
&#125;
</code></pre>
<p>流程如下：</p>
<ol>
<li>根据key计算出hashcode，定位到桶的位置</li>
<li>如果桶为空，直接返回null</li>
<li>不然遍历该桶，比较key，value，hash值是否相等；如果相等就返回值，不然返回null</li>
</ol>
<h2 id="HaspMap在1-8的实现"><a href="#HaspMap在1-8的实现" class="headerlink" title="HaspMap在1.8的实现"></a>HaspMap在1.8的实现</h2><p>1.8相比较1.7的改变主要在以下几个点：</p>
<ol>
<li>将Entry更改为Node</li>
<li>在链表长度超过8时就更改为红黑树，加快查询。</li>
<li>添加static final int TREEIFY_THRESHOLD &#x3D; 8变量。</li>
<li>链表头插法改为尾插法（保持原来的顺序），就要为了解决并发put导致resize出现死循环。</li>
</ol>
<p>以上这些改变都是为了解决hash冲突时链表长度过长，导致查询效率下降的问题，通过将长度超过8的链表转为红黑树来加快查询。此时的数据结构如下：<br><img src="https://i.imgur.com/KZQGEtv.jpg"></p>
<h3 id="put方法-1"><a href="#put方法-1" class="headerlink" title="put方法"></a>put方法</h3><p>HashMap存放数据1.8源码：</p>
<pre><code>public V put(K key, V value) &#123;
    return putVal(hash(key), key, value, false, true);
&#125;

/**
 * Implements Map.put and related methods.
 *
 * @param hash hash for key
 * @param key the key
 * @param value the value to put
 * @param onlyIfAbsent if true, don&#39;t change existing value
 * @param evict if false, the table is in creation mode.
 * @return previous value, or null if none
 */
final V putVal(int hash, K key, V value, boolean onlyIfAbsent,
               boolean evict) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;
    if ((tab = table) == null || (n = tab.length) == 0)
        n = (tab = resize()).length;
    if ((p = tab[i = (n - 1) &amp; hash]) == null)
        tab[i] = newNode(hash, key, value, null);
    else &#123;
        Node&lt;K,V&gt; e; K k;
        if (p.hash == hash &amp;&amp;
            ((k = p.key) == key || (key != null &amp;&amp; key.equals(k))))
            e = p;
        else if (p instanceof TreeNode)
            e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);
        else &#123;
            for (int binCount = 0; ; ++binCount) &#123;
                if ((e = p.next) == null) &#123;
                    p.next = newNode(hash, key, value, null);
                    if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st
                        treeifyBin(tab, hash);
                    break;
                &#125;
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    break;
                p = e;
            &#125;
        &#125;
        if (e != null) &#123; // existing mapping for key
            V oldValue = e.value;
            if (!onlyIfAbsent || oldValue == null)
                e.value = value;
            afterNodeAccess(e);
            return oldValue;
        &#125;
    &#125;
    ++modCount;
    if (++size &gt; threshold)
        resize();
    afterNodeInsertion(evict);
    return null;
&#125;
</code></pre>
<p>流程如下：</p>
<ol>
<li>判断桶数组是否为空；如果为空通过resize()来初始化桶数组。</li>
<li>否则通过hash定位到桶位置；若果桶为空，新建一个Node节点（或者说新桶）。</li>
<li>否则先判断当前桶的hash，key与写入的hash，key是否相等；相等的话将值赋予给e；</li>
<li>如果当前桶是红黑树，就以红黑树的方式写入；</li>
<li>如果是个链表，如果在遍历过程中找到 key 相同时直接退出遍历。</li>
<li>如果没有找到相同的节点，就需要将当前的 key、value 封装成一个新节点写入到当前桶的后面（形成链表）赋予给e，接着判断当前链表的大小是否大于预设的阈值，大于时就要转换为红黑树。</li>
<li>判断，如果 e !&#x3D; null 就相当于存在相同的 key,那就需要将值覆盖。</li>
<li>最后判断是否需要进行扩容。</li>
</ol>
<h3 id="get方法-1"><a href="#get方法-1" class="headerlink" title="get方法"></a>get方法</h3><p>HashMap获取数据1.8源码如下：</p>
<pre><code>public V get(Object key) &#123;
    Node&lt;K,V&gt; e;
    return (e = getNode(hash(key), key)) == null ? null : e.value;
&#125;

/**
 * Implements Map.get and related methods.
 *
 * @param hash hash for key
 * @param key the key
 * @return the node, or null if none
 */
final Node&lt;K,V&gt; getNode(int hash, Object key) &#123;
    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k;
    if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp;
        (first = tab[(n - 1) &amp; hash]) != null) &#123;
        if (first.hash == hash &amp;&amp; // always check first node
            ((k = first.key) == key || (key != null &amp;&amp; key.equals(k))))
            return first;
        if ((e = first.next) != null) &#123;
            if (first instanceof TreeNode)
                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);
            do &#123;
                if (e.hash == hash &amp;&amp;
                    ((k = e.key) == key || (key != null &amp;&amp; key.equals(k))))
                    return e;
            &#125; while ((e = e.next) != null);
        &#125;
    &#125;
    return null;
&#125;
</code></pre>
<p>流程如下：</p>
<ol>
<li>首先将 key hash 之后取得所定位的桶。</li>
<li>如果桶为空则直接返回 null 。</li>
<li>否则判断桶的第一个位置(有可能是链表、红黑树)的 key 是否为查询的 key，是就直接返回 value。</li>
<li>如果第一个不匹配，则判断它的下一个是红黑树还是链表。</li>
<li>红黑树就按照树的查找方式返回值。</li>
<li>不然就按照链表的方式遍历匹配返回值。</li>
</ol>
<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><hr>
<h2 id="ConcurrentHashMap在1-7中的实现"><a href="#ConcurrentHashMap在1-7中的实现" class="headerlink" title="ConcurrentHashMap在1.7中的实现"></a>ConcurrentHashMap在1.7中的实现</h2><h3 id="基本数据结构"><a href="#基本数据结构" class="headerlink" title="基本数据结构"></a>基本数据结构</h3><p><img src="https://i.imgur.com/7xWGOSn.jpg"></p>
<p>ConcurrentHashMap 采用了分段锁技术，其中 Segment 继承于 ReentrantLock，不会像 HashTable 那样不管是 put 还是 get 操作都需要做同步处理。无论是读操作还是写操作都能保证很高的性能：在进行读操作时(几乎)不需要加锁，而在写操作时通过锁分段技术只对所操作的段加锁而不影响客户端对其它段的访问。特别地，在理想状态下，ConcurrentHashMap 可以支持 16 个线程执行并发写操作（如果并发级别设为16），及任意数量线程的读操作。</p>
<p>ConcurrentHashMap的高效并发机制是通过以下三方面来保证的：</p>
<ol>
<li><p>通过锁分段技术保证并发环境下的写操作；</p>
</li>
<li><p>通过 HashEntry的不变性、Volatile变量的内存可见性和加锁重读机制保证高效、安全的读操作；</p>
</li>
<li><p>通过不加锁和加锁两种方案控制跨段操作的的安全性。</p>
</li>
</ol>
<p>主要变量如下：</p>
<pre><code>/**
 * Mask value for indexing into segments. The upper bits of a
 * key&#39;s hash code are used to choose the segment.
 */
final int segmentMask;  // 用于定位段，大小等于segments数组的大小减 1，是不可变的

/**
 * Shift value for indexing within segments.
 */
final int segmentShift;    // 用于定位段，大小等于32(hash值的位数)减去对segments的大小取以2为底的对数值，是不可变的

/**
 * The segments, each of which is a specialized hash table
 */
final Segment&lt;K,V&gt;[] segments;   // ConcurrentHashMap的底层结构是一个Segment数组
</code></pre>
<p>Segment类主要组成：</p>
<pre><code>// 
static final class Segment&lt;K,V&gt; extends ReentrantLock implements Serializable &#123;

    /**
     * The number of elements in this segment&#39;s region.
     */
    transient volatile int count;    // Segment中元素的数量，可见的

    /**
     * Number of updates that alter the size of the table. This is
     * used during bulk-read methods to make sure they see a
     * consistent snapshot: If modCounts change during a traversal
     * of segments computing size or checking containsValue, then
     * we might have an inconsistent view of state so (usually)
     * must retry.
     */
    transient int modCount;  //对count的大小造成影响的操作的次数（比如put或者remove操作）

    /**
     * The table is rehashed when its size exceeds this threshold.
     * (The value of this field is always &lt;tt&gt;(int)(capacity *
     * loadFactor)&lt;/tt&gt;.)
     */
    transient int threshold;      // 阈值，段中元素的数量超过这个值就会对Segment进行扩容

    /**
     * The per-segment table.
     */
    transient volatile HashEntry&lt;K,V&gt;[] table;  // 链表数组

    /**
     * The load factor for the hash table.  Even though this value
     * is same for all segments, it is replicated to avoid needing
     * links to outer object.
     * @serial
     */
    final float loadFactor;  // 段的负载因子，其值等同于ConcurrentHashMap的负载因子

    ...
&#125;
</code></pre>
<p>HashEntry类</p>
<pre><code> /**
 * HashMap 中的 Entry 类
 */
static class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;
    final K key;
    V value;
    Entry&lt;K,V&gt; next;
    final int hash;

    /**
     * Creates new entry.
     */
    Entry(int h, K k, V v, Entry&lt;K,V&gt; n) &#123;
        value = v;
        next = n;
        key = k;
        hash = h;
    &#125;
    ...
&#125;
</code></pre>
<h3 id="put方法-2"><a href="#put方法-2" class="headerlink" title="put方法"></a>put方法</h3><pre><code>public V put(K key, V value) &#123;
    Segment&lt;K,V&gt; s;
    if (value == null)
        throw new NullPointerException();
    int hash = hash(key);
    int j = (hash &gt;&gt;&gt; segmentShift) &amp; segmentMask;
    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObject          // nonvolatile; recheck
         (segments, (j &lt;&lt; SSHIFT) + SBASE)) == null) //  in ensureSegment
        s = ensureSegment(j);
    return s.put(key, hash, value, false);
&#125;

final V put(K key, int hash, V value, boolean onlyIfAbsent) &#123;
    HashEntry&lt;K,V&gt; node = tryLock() ? null :
        scanAndLockForPut(key, hash, value);
    V oldValue;
    try &#123;
        HashEntry&lt;K,V&gt;[] tab = table;
        int index = (tab.length - 1) &amp; hash;
        HashEntry&lt;K,V&gt; first = entryAt(tab, index);
        for (HashEntry&lt;K,V&gt; e = first;;) &#123;
            if (e != null) &#123;
                K k;
                if ((k = e.key) == key ||
                    (e.hash == hash &amp;&amp; key.equals(k))) &#123;
                    oldValue = e.value;
                    if (!onlyIfAbsent) &#123;
                        e.value = value;
                        ++modCount;
                    &#125;
                    break;
                &#125;
                e = e.next;
            &#125;
            else &#123;
                if (node != null)
                    node.setNext(first);
                else
                    node = new HashEntry&lt;K,V&gt;(hash, key, value, first);
                int c = count + 1;
                if (c &gt; threshold &amp;&amp; tab.length &lt; MAXIMUM_CAPACITY)
                    rehash(node);
                else
                    setEntryAt(tab, index, node);
                ++modCount;
                count = c;
                oldValue = null;
                break;
            &#125;
        &#125;
    &#125; finally &#123;
        unlock();
    &#125;
    return oldValue;
&#125;
</code></pre>
<p>流程如下：</p>
<ol>
<li><p>根据key的hash值定位到Segment</p>
</li>
<li><p>利用 scanAndLockForPut() 获得Segment的锁</p>
<ul>
<li>尝试自旋获取锁。</li>
<li>如果重试的次数达到了 MAX_SCAN_RETRIES 则改为阻塞锁获取，保证能获取成功。</li>
</ul>
</li>
<li><p>将当前 Segment 中的 table 通过 key 的 hashcode 定位到 HashEntry。</p>
</li>
<li><p>遍历该 HashEntry，如果不为空则判断传入的 key 和当前遍历的 key 是否相等，相等则覆盖旧的 value。不为空则需要新建一个 HashEntry 并加入到 Segment 中，同时会先判断是否需要扩容。</p>
</li>
<li><p>最后会解除所获取当前 Segment 的锁。</p>
</li>
</ol>
<h3 id="get方法-2"><a href="#get方法-2" class="headerlink" title="get方法"></a>get方法</h3><pre><code>public V get(Object key) &#123;
    Segment&lt;K,V&gt; s; // manually integrate access methods to reduce overhead
    HashEntry&lt;K,V&gt;[] tab;
    int h = hash(key);
    long u = (((h &gt;&gt;&gt; segmentShift) &amp; segmentMask) &lt;&lt; SSHIFT) + SBASE;
    if ((s = (Segment&lt;K,V&gt;)UNSAFE.getObjectVolatile(segments, u)) != null &amp;&amp;
        (tab = s.table) != null) &#123;
        for (HashEntry&lt;K,V&gt; e = (HashEntry&lt;K,V&gt;) UNSAFE.getObjectVolatile
                 (tab, ((long)(((tab.length - 1) &amp; h)) &lt;&lt; TSHIFT) + TBASE);
             e != null; e = e.next) &#123;
            K k;
            if ((k = e.key) == key || (e.hash == h &amp;&amp; key.equals(k)))
                return e.value;
        &#125;
    &#125;
    return null;
&#125;
</code></pre>
<h2 id="ConcurrentHashMap在1-8中的实现"><a href="#ConcurrentHashMap在1-8中的实现" class="headerlink" title="ConcurrentHashMap在1.8中的实现"></a>ConcurrentHashMap在1.8中的实现</h2><p>1.8相较于1.7更改主要在一下几个点：</p>
<ul>
<li>抛弃了原有的 Segment 分段锁，而采用了 CAS + synchronized 来保证并发安全性</li>
<li>存放数据的 HashEntry 改为 Node，但作用都是相同的</li>
<li>val next 都用了 volatile 修饰，保证了可见性</li>
<li>链表长度超过8就采用红黑树来实现</li>
</ul>
<p>主要引用：</p>
<blockquote>
<p><a href="https://crossoverjie.top/2018/07/23/java-senior/ConcurrentHashMap/">HashMap? ConcurrentHashMap? 相信看完这篇没人能难住你</a></p>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/justloveyou_/article/details/72783008">Map 综述（三）：彻头彻尾理解 ConcurrentHashMap</a></p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/21/stanfordCoreNLP%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/image.png">
      <meta itemprop="name" content="三十而立">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三十而立的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三十而立的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/21/stanfordCoreNLP%E7%9A%84%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/" class="post-title-link" itemprop="url">stanfordCoreNLP的使用方式</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-21 17:09:10" itemprop="dateCreated datePublished" datetime="2019-01-21T17:09:10+08:00">2019-01-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-21 23:32:32" itemprop="dateModified" datetime="2025-09-21T23:32:32+08:00">2025-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/" itemprop="url" rel="index"><span itemprop="name">python</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/python/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/" itemprop="url" rel="index"><span itemprop="name">自然语言处理</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>709</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <p>#使用Standford Core NLP的几种方法</p>
<p>stanford corenlp 2018-02-27<br>java环境： 1.8 64位</p>
<p>因为斯坦福corenlp最新版都推荐使用服务器来运行，且nltk包不在支持，直接调用会出现一些问题，建议使用服务器来使用</p>
<hr>
<p>##1 使用Core nlp服务器，在来连接服务器</p>
<ul>
<li><p>创建Core nlp服务器</p>
<p>  在命令行中进入corenlp文件所在位置，输入开启服务器命令</p>
<pre><code>  e:
  cd E:\corenlp\stanford-corenlp-full-2018-02-27 
  java -mx4g -cp &quot;*&quot; edu.stanford.nlp.pipeline.StanfordCoreNLPServer -port 9000 -timeout 15000
</code></pre>
</li>
<li><p>使用nltk（3.3v以上）包连接服务器<br>  API网址：<a href="https://www.nltk.org/_modules/nltk/parse/corenlp.html">https://www.nltk.org/_modules/nltk/parse/corenlp.html</a><br>  &gt;&gt;&gt; from nltk.parse import CoreNLPParser<br><br>  # Lexical Parser<br>  &gt;&gt;&gt; parser &#x3D; CoreNLPParser(url&#x3D;’<a href="http://localhost:9000/">http://localhost:9000</a>‘)<br><br>  # Parse tokenized text.<br>  &gt;&gt;&gt; list(parser.parse(‘What is the airspeed of an unladen swallow ?’.split()))<br>  [Tree(‘ROOT’, [Tree(‘SBARQ’, [Tree(‘WHNP’, [Tree(‘WP’, [‘What’])]), Tree(‘SQ’, [Tree(‘VBZ’, [‘is’]), Tree(‘NP’, [Tree(‘NP’, [Tree(‘DT’, [‘the’]), Tree(‘NN’, [‘airspeed’])]), Tree(‘PP’, [Tree(‘IN’, [‘of’]), Tree(‘NP’, [Tree(‘DT’, [‘an’]), Tree(‘JJ’, [‘unladen’])])]), Tree(‘S’, [Tree(‘VP’, [Tree(‘VB’, [‘swallow’])])])])]), Tree(‘.’, [‘?’])])])]<br><br>  # Parse raw string.<br>  &gt;&gt;&gt; list(parser.raw_parse(‘What is the airspeed of an unladen swallow ?’))<br>  [Tree(‘ROOT’, [Tree(‘SBARQ’, [Tree(‘WHNP’, [Tree(‘WP’, [‘What’])]), Tree(‘SQ’, [Tree(‘VBZ’, [‘is’]), Tree(‘NP’, [Tree(‘NP’, [Tree(‘DT’, [‘the’]), Tree(‘NN’, [‘airspeed’])]), Tree(‘PP’, [Tree(‘IN’, [‘of’]), Tree(‘NP’, [Tree(‘DT’, [‘an’]), Tree(‘JJ’, [‘unladen’])])]), Tree(‘S’, [Tree(‘VP’, [Tree(‘VB’, [‘swallow’])])])])]), Tree(‘.’, [‘?’])])])]<br><br>  # Neural Dependency Parser<br>  &gt;&gt;&gt; from nltk.parse.corenlp import CoreNLPDependencyParser<br>  &gt;&gt;&gt; dep_parser &#x3D; CoreNLPDependencyParser(url&#x3D;’<a href="http://localhost:9000/">http://localhost:9000</a>‘)<br>  &gt;&gt;&gt; parses &#x3D; dep_parser.parse(‘What is the airspeed of an unladen swallow ?’.split())<br>  &gt;&gt;&gt; [[(governor, dep, dependent) for governor, dep, dependent in parse.triples()] for parse in parses]<br>  [[((‘What’, ‘WP’), ‘cop’, (‘is’, ‘VBZ’)), ((‘What’, ‘WP’), ‘nsubj’, (‘airspeed’, ‘NN’)), ((‘airspeed’, ‘NN’), ‘det’, (‘the’, ‘DT’)), ((‘airspeed’, ‘NN’), ‘nmod’, (‘swallow’, ‘VB’)), ((‘swallow’, ‘VB’), ‘case’, (‘of’, ‘IN’)), ((‘swallow’, ‘VB’), ‘det’, (‘an’, ‘DT’)), ((‘swallow’, ‘VB’), ‘amod’, (‘unladen’, ‘JJ’)), ((‘What’, ‘WP’), ‘punct’, (‘?’, ‘.’))]]<br><br><br>  # Tokenizer 分词<br>  &gt;&gt;&gt; parser &#x3D; CoreNLPParser(url&#x3D;’<a href="http://localhost:9000/">http://localhost:9000</a>‘)<br>  &gt;&gt;&gt; list(parser.tokenize(‘What is the airspeed of an unladen swallow?’))<br>  [‘What’, ‘is’, ‘the’, ‘airspeed’, ‘of’, ‘an’, ‘unladen’, ‘swallow’, ‘?’]<br><br>  # POS Tagger 词性标注<br>  &gt;&gt;&gt; pos_tagger &#x3D; CoreNLPParser(url&#x3D;’<a href="http://localhost:9000/">http://localhost:9000</a>‘, tagtype&#x3D;’pos’)<br>  &gt;&gt;&gt; list(pos_tagger.tag(‘What is the airspeed of an unladen swallow ?’.split()))<br>  [(‘What’, ‘WP’), (‘is’, ‘VBZ’), (‘the’, ‘DT’), (‘airspeed’, ‘NN’), (‘of’, ‘IN’), (‘an’, ‘DT’), (‘unladen’, ‘JJ’), (‘swallow’, ‘VB’), (‘?’, ‘.’)]<br><br>  # NER Tagger 命名实体识别<br>  &gt;&gt;&gt; ner_tagger &#x3D; CoreNLPParser(url&#x3D;’<a href="http://localhost:9000/">http://localhost:9000</a>‘, tagtype&#x3D;’ner’)<br>  &gt;&gt;&gt; list(ner_tagger.tag((‘Rami Eid is studying at Stony Brook University in NY’.split())))<br>  [(‘Rami’, ‘PERSON’), (‘Eid’, ‘PERSON’), (‘is’, ‘O’), (‘studying’, ‘O’), (‘at’, ‘O’), (‘Stony’, ‘ORGANIZATION’), (‘Brook’, ‘ORGANIZATION’), (‘University’, ‘ORGANIZATION’), (‘in’, ‘O’), (‘NY’, ‘STATE_OR_PROVINCE’)]</p>
</li>
<li><p>或者使用from stanfordcorenlp import StanfordCoreNLP，网址为<a href="https://github.com/Lynten/stanford-corenlp">https://github.com/Lynten/stanford-corenlp</a><br>  nlp &#x3D; StanfordCoreNLP(‘<a href="http://localhost/">http://localhost</a>‘, port&#x3D;9000)<br>  # 常用api<br>  print ‘Tokenize:’, nlp.word_tokenize(sentence)<br>  print ‘Part of Speech:’, nlp.pos_tag(sentence)<br>  print ‘Named Entities:’, nlp.ner(sentence)<br>  print ‘Constituency Parsing:’, nlp.parse(sentence)<br>  print ‘Dependency Parsing:’, nlp.dependency_parse(sentence)<br><br>  # 一般的<br>  # annotators: tokenize, ssplit, pos, lemma, ner, parse, depparse, dcoref (See Detail)<br><br>  # pipelineLanguage: en, zh, ar, fr, de, es (English, Chinese, Arabic, French, German, Spanish) (See Annotator Support Detail)<br><br>  # outputFormat: json, xml, text<br>  props &#x3D; {‘annotators’: ‘tokenize, ssplit, ner, depparse’, ‘pipelineLanguage’: ‘en’, ‘outputFormat’: ‘json’}<br>  ParseResult &#x3D; nlp.annotate(raw_sent, properties&#x3D;props)<br><br><br>  nlp.close（）＃别忘了关闭！后端服务器将消耗大量的memery。</p>
</li>
</ul>
<h2 id="2-不使用服务器（不推荐，以不更新）"><a href="#2-不使用服务器（不推荐，以不更新）" class="headerlink" title="2 不使用服务器（不推荐，以不更新）"></a>2 不使用服务器（不推荐，以不更新）</h2><p>使用nltk直接调用包<br>2018-12-28测试发现侧方法会出现utf8解析问题，暂时无法解决，推荐使用上面的方法。<br>    # java路径，需要修改<br>    java_path &#x3D; “C:\Program Files\Java\jre1.8.0_191\bin\java.exe”<br>    os.environ[‘JAVA_HOME’] &#x3D; java_path<br>    os.environ[“STANFORD_PARSER”] &#x3D; Utils.get_project_path()+”\lib_data\stanford-parser-full-2018-02-27\stanford-parser.jar”<br>    os.environ[“STANFORD_MODELS”] &#x3D; Utils.get_project_path()+”\lib_data\stanford-parser-full-2018-02-27\stanford-parser-3.9.1-models.jar”</p>
<pre><code>self.sent_parser = stanford.StanfordParser(
                             model_path=&quot;edu/stanford/nlp/models/lexparser/englishPCFG.ser.gz&quot;,
                           java_options=&#39;-mx8g&#39;,
                            encoding=&#39;utf8&#39;)  #&#39;-mlength100&#39;
t1 = list(self.sent_parser.parse((senten,))
</code></pre>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/21/spring%E8%A3%85%E9%85%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/image.png">
      <meta itemprop="name" content="三十而立">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三十而立的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三十而立的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/21/spring%E8%A3%85%E9%85%8D/" class="post-title-link" itemprop="url">spring装配</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-21 17:05:13" itemprop="dateCreated datePublished" datetime="2019-01-21T17:05:13+08:00">2019-01-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-21 23:32:32" itemprop="dateModified" datetime="2025-09-21T23:32:32+08:00">2025-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>719</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>3 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Spring装配Bean"><a href="#Spring装配Bean" class="headerlink" title="Spring装配Bean"></a>Spring装配Bean</h2><hr>
<p>Spring容器配置的三种主要的装配机制：</p>
<blockquote>
<ul>
<li>在XML中进行显示配置</li>
<li>在Java中进行显式配置</li>
<li>隐式的bean发现机制和自动装配</li>
</ul>
</blockquote>
<h3 id="1-自动装配"><a href="#1-自动装配" class="headerlink" title="1-自动装配"></a>1-自动装配</h3><p>Spring从两个角度实现自动化装配：</p>
<blockquote>
<ul>
<li>组件扫描（component scanning） 自动发现应用上下文中所创建的bean</li>
<li>自动装配（autowiring） Spring自动满足bean之间的依赖</li>
</ul>
</blockquote>
<p>  使用@Component注解来告诉Spring为这个类创建bean</p>
<pre><code>@Component
public class CDPlayer implements MediaPlayer &#123;
  private CompactDisc cd;

  @Autowired
  public CDPlayer(CompactDisc cd) &#123;
    this.cd = cd;
  &#125;

  public void play() &#123;
    cd.play();
  &#125;

&#125;
</code></pre>
<p>通过设置组件扫描可以不用显示配置bean。但是组件扫描默认是不启用的。所以要通过配置来启用。</p>
<ul>
<li><p>在java配置类中开启组件扫描@ComponentScan</p>
<pre><code>  @Configuration
  @ComponentScan
  public class CDPlayerConfig &#123; 
  &#125;
</code></pre>
</li>
</ul>
<p>因为@ComponentScan会扫描与配置类相同的包。可以通过下面两个配置来设置扫描的包：</p>
<blockquote>
<ul>
<li>@ComponentScan(basePackages&#x3D;{“soundsystem,”sdd”})<blockquote>
<p>扫描包的名字</p>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>@ComponentScan(basePackageClasses&#x3D;{CDplayer.class,DVDPlayer.class})<blockquote>
<p>扫描类所在的包</p>
</blockquote>
</li>
</ul>
</blockquote>
<ul>
<li><p>在XML中开启组件扫描</p>
<pre><code>  &lt;context:component-scan base-package=&quot;soundsystem&quot; /&gt;
</code></pre>
</li>
<li><p>为组件扫描的bean命名</p>
<blockquote>
<ul>
<li>通过@Component注解</li>
</ul>
</blockquote>
<p>  @Component(“sgtPerr”)<br>  public class SgtPeppers implements CompactDisc {</p>
<pre><code>private String title = &quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot;;  
private String artist = &quot;The Beatles&quot;;

public void play() &#123;
  System.out.println(&quot;Playing &quot; + title + &quot; by &quot; + artist);
&#125;
</code></pre>
<p>  }</p>
</li>
</ul>
<blockquote>
<ul>
<li>通过@Named注解</li>
</ul>
</blockquote>
<pre><code>@Named(&quot;sgtPerr&quot;)
public class SgtPeppers implements CompactDisc &#123;

&#125;
</code></pre>
<h3 id="2-JAVA代码装配Bean"><a href="#2-JAVA代码装配Bean" class="headerlink" title="2- JAVA代码装配Bean"></a>2- JAVA代码装配Bean</h3><p>通过配置类来实现装配Bean</p>
<pre><code>@Configuration //表明这是一个配置类
public class CDPlayerConfig &#123;
  
  @Bean //声明这是一个bean
  public CompactDisc compactDisc() &#123;
    return new SgtPeppers();
  &#125;

  @Bean
    //通过构造器注入
  public CDPlayer cdPlayer(CompactDisc compactDisc) &#123;
    return new CDPlayer(compactDisc);
  &#125;

  @Bean 
    //通过setter方法注入
  public CDPlayer cdPlayer(CompactDisc compactDisc) &#123;
    CDPlayer cdPlayer = new CDPlayer(compactDisc);
    cdPlayer.setCompactDisc(compactDisc);
    return cdPlayer
  &#125;

&#125;
</code></pre>
<h3 id="3-通过XML装配bean"><a href="#3-通过XML装配bean" class="headerlink" title="3- 通过XML装配bean"></a>3- 通过XML装配bean</h3><blockquote>
<ul>
<li>通过构造器注入</li>
</ul>
</blockquote>
<pre><code>&lt;bean id=&quot;compactDisc&quot; class=&quot;soundsystem.collections.BlankDisc&quot;&gt;
    &lt;constructor-arg value=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot; /&gt;
    &lt;constructor-arg value=&quot;The Beatles&quot; /&gt;
    &lt;constructor-arg&gt;
      &lt;list&gt;
        &lt;value&gt;Sgt. Pepper&#39;s Lonely Hearts Club Band&lt;/value&gt;
        &lt;value&gt;With a Little Help from My Friends&lt;/value&gt;
        &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt;
        &lt;value&gt;Getting Better&lt;/value&gt;
        &lt;value&gt;Fixing a Hole&lt;/value&gt;
        &lt;value&gt;She&#39;s Leaving Home&lt;/value&gt;
        &lt;value&gt;Being for the Benefit of Mr. Kite!&lt;/value&gt;
        &lt;value&gt;Within You Without You&lt;/value&gt;
        &lt;value&gt;When I&#39;m Sixty-Four&lt;/value&gt;
        &lt;value&gt;Lovely Rita&lt;/value&gt;
        &lt;value&gt;Good Morning Good Morning&lt;/value&gt;
        &lt;value&gt;Sgt. Pepper&#39;s Lonely Hearts Club Band (Reprise)&lt;/value&gt;
        &lt;value&gt;A Day in the Life&lt;/value&gt;
      &lt;/list&gt;
    &lt;/constructor-arg&gt;
  &lt;/bean&gt;
</code></pre>
<blockquote>
<ul>
<li>通过setter注入</li>
</ul>
</blockquote>
<pre><code> &lt;bean id=&quot;compactDisc&quot;
    class=&quot;soundsystem.properties.BlankDisc&quot;&gt;
    &lt;property name=&quot;title&quot; value=&quot;Sgt. Pepper&#39;s Lonely Hearts Club Band&quot; /&gt;
    &lt;property name=&quot;artist&quot; value=&quot;The Beatles&quot; /&gt;
    &lt;property name=&quot;tracks&quot;&gt;
      &lt;list&gt;
        &lt;value&gt;Sgt. Pepper&#39;s Lonely Hearts Club Band&lt;/value&gt;
        &lt;value&gt;With a Little Help from My Friends&lt;/value&gt;
        &lt;value&gt;Lucy in the Sky with Diamonds&lt;/value&gt;
        &lt;value&gt;Getting Better&lt;/value&gt;
        &lt;value&gt;Fixing a Hole&lt;/value&gt;
        &lt;value&gt;She&#39;s Leaving Home&lt;/value&gt;
        &lt;value&gt;Being for the Benefit of Mr. Kite!&lt;/value&gt;
        &lt;value&gt;Within You Without You&lt;/value&gt;
        &lt;value&gt;When I&#39;m Sixty-Four&lt;/value&gt;
        &lt;value&gt;Lovely Rita&lt;/value&gt;
        &lt;value&gt;Good Morning Good Morning&lt;/value&gt;
        &lt;value&gt;Sgt. Pepper&#39;s Lonely Hearts Club Band (Reprise)&lt;/value&gt;
        &lt;value&gt;A Day in the Life&lt;/value&gt;
      &lt;/list&gt;
    &lt;/property&gt;
  &lt;/bean&gt;
</code></pre>
<h3 id="4-混合配置"><a href="#4-混合配置" class="headerlink" title="4-混合配置"></a>4-混合配置</h3><ul>
<li><p>在javaConfig引用xml配置</p>
<pre><code>  @Configuration
  @Import(CDPlayerConfig.class) //导入其他的java配置
  @ImportResource(&quot;classpath:cd-config.xml&quot;) // 导入xml配置
  public class SoundSystemConfig &#123;
  
  &#125;
</code></pre>
</li>
<li><p>在xml配置中引用javaconfig</p>
<pre><code>  &lt;bean class=&quot;soundsystem.CDConfig&quot; /&gt; 导入config配置类
  &lt;import resource=&quot;cd-player-config.xml&quot;/&gt; 导入xml配置
</code></pre>
</li>
</ul>
<hr>
<p>##高级装配</p>
<h3 id="1-环境与profile"><a href="#1-环境与profile" class="headerlink" title="1- 环境与profile"></a>1- 环境与profile</h3>
      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




    


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/01/21/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/uploads/image.png">
      <meta itemprop="name" content="三十而立">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="三十而立的博客">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="undefined | 三十而立的博客">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          <a href="/2019/01/21/java%E5%A4%9A%E7%BA%BF%E7%A8%8B/" class="post-title-link" itemprop="url">java多线程</a>
        </h2>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-01-21 17:04:50" itemprop="dateCreated datePublished" datetime="2019-01-21T17:04:50+08:00">2019-01-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar-check"></i>
      </span>
      <span class="post-meta-item-text">更新于</span>
      <time title="修改时间：2025-09-21 23:32:32" itemprop="dateModified" datetime="2025-09-21T23:32:32+08:00">2025-09-21</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/java/" itemprop="url" rel="index"><span itemprop="name">java</span></a>
        </span>
    </span>

  
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>2.4k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
          <h2 id="Java多线程简单使用"><a href="#Java多线程简单使用" class="headerlink" title="Java多线程简单使用"></a>Java多线程简单使用</h2><h3 id="继承Thread类"><a href="#继承Thread类" class="headerlink" title="继承Thread类"></a>继承Thread类</h3><p>通过继承Thread，重写run方法</p>
<pre><code>public class MyThread extends Thread&#123;

    @Override
    public void run() &#123;
        super.run();
        System.out.println(&quot;MyThread&quot;);
    &#125;
&#125;
</code></pre>
<p>测试代码：</p>
<pre><code>@Test
public void test1()&#123;
    MyThread myThread = new MyThread();
    myThread.start();
    System.out.println(&quot;运行结束&quot;);

&#125;
</code></pre>
<blockquote>
<p>因为java是单根继承，不支持多继承，在程序设计上是有局限的。</p>
</blockquote>
<h3 id="实现Runnable接口（推荐）"><a href="#实现Runnable接口（推荐）" class="headerlink" title="实现Runnable接口（推荐）"></a>实现Runnable接口（推荐）</h3><p>实现Runnale接口，重写run方法</p>
<pre><code>public class MyRunnable implements Runnable &#123;

    @Override
    public void run() &#123;
        System.out.println(&quot;running&quot;);
    &#125;
&#125;
</code></pre>
<p>测试代码：</p>
<pre><code>@Test
public void test2()&#123;
    MyRunnable myRunnable = new MyRunnable();
    Thread thread = new Thread(myRunnable);
    thread.start();
    System.out.println(&quot;ending&quot;);

&#125;
</code></pre>
<blockquote>
<ul>
<li>注意，这里测试代码是实现Runnable接口后，通过Thread来接受Runnable接口对象，这样可以让Thread的start方法来调用Run方法，起到多线程的作用。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>如果直接在主程序中调用run方法，就仅仅是程序的调用，无法起到多线程的作用。</li>
</ul>
</blockquote>
<hr>
<h2 id="java多线程的同步"><a href="#java多线程的同步" class="headerlink" title="java多线程的同步"></a>java多线程的同步</h2><h3 id="synchronize实现同步"><a href="#synchronize实现同步" class="headerlink" title="synchronize实现同步"></a>synchronize实现同步</h3><p>java中的每一个对象都可以作为锁，具体表现形式为下面三种形式：</p>
<blockquote>
<ul>
<li>对于普通同步方法，锁是当前实例对象</li>
<li>对于静态同步方法，锁是当前类的class对象</li>
<li>对于同步方法块，锁是Synchronize括号里配置的对象</li>
</ul>
</blockquote>
<p>上面三种形式默认synchronized相当于synchronized（this）锁this对象。</p>
<p>对于synchronized(非this对象x)这种情况，有下属三种结论：</p>
<blockquote>
<ul>
<li>当多个线程同时执行synchronized（x）{}同步代码块呈现同步效果。</li>
<li>当其它线程执行x对象中synchronized同步方法呈现同步效果</li>
<li>当其它线程执行x对象方法里面的synchronized（this）代码块也呈现同步效果。</li>
</ul>
</blockquote>
<h3 id="volatile关键字"><a href="#volatile关键字" class="headerlink" title="volatile关键字"></a>volatile关键字</h3><p>关键字volatile主要作用是使变量在多个线程间可见</p>
<hr>
<h2 id="Java线程间通信"><a href="#Java线程间通信" class="headerlink" title="Java线程间通信"></a>Java线程间通信</h2><h3 id="等待-通知机制"><a href="#等待-通知机制" class="headerlink" title="等待&#x2F;通知机制"></a>等待&#x2F;通知机制</h3><p><img src="/"></p>
<p>等待&#x2F;通知机制，是指一个线程A调用了对象O的wait()方法进入等待状态，而另一个线程B<br>调用了对象O的notify()或者notifyAll()方法，线程A收到通知后从对象O的wait()方法返回，进而<br>执行后续操作。上述两个线程通过对象O来完成交互，而对象上的wait()和notify&#x2F;notifyAll()的<br>关系就如同开关信号一样，用来完成等待方和通知方之间的交互工作。</p>
<pre><code>public class WaitNotify &#123;
    static boolean flag = true;
    static Object  lock = new Object();

    public static void main(String[] args) throws Exception &#123;
        Thread waitThread = new Thread(new Wait(), &quot;WaitThread&quot;);
        waitThread.start();
        TimeUnit.SECONDS.sleep(1);

        Thread notifyThread = new Thread(new Notify(), &quot;NotifyThread&quot;);
        notifyThread.start();
    &#125;

    static class Wait implements Runnable &#123;
        public void run() &#123;
            // 加锁，拥有lock的Monitor
            synchronized (lock) &#123;
                // 当条件不满足时，继续wait，同时释放了lock的锁
                while (flag) &#123;
                    try &#123;
                        System.out.println(Thread.currentThread() + &quot; flag is true. wait @ &quot;
                                           + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
                        lock.wait();
                    &#125; catch (InterruptedException e) &#123;
                    &#125;
                &#125;
                // 条件满足时，完成工作
                System.out.println(Thread.currentThread() + &quot; flag is false. running @ &quot;
                                   + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
            &#125;
        &#125;
    &#125;

    static class Notify implements Runnable &#123;
        public void run() &#123;
            // 加锁，拥有lock的Monitor
            synchronized (lock) &#123;
                // 获取lock的锁，然后进行通知，通知时不会释放lock的锁，
                // 直到当前线程释放了lock后，WaitThread才能从wait方法中返回
                System.out.println(Thread.currentThread() + &quot; hold lock. notify @ &quot; + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
                lock.notifyAll();
                flag = false;
                SleepUtils.second(5);
            &#125;
            // 再次加锁
            synchronized (lock) &#123;
                System.out.println(Thread.currentThread() + &quot; hold lock again. sleep @ &quot;
                                   + new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(new Date()));
                SleepUtils.second(5);
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<p>我们在使用这些方法需要注意下面几点：</p>
<ul>
<li><p>1）使用wait()、notify()和notifyAll()时需要先对调用对象加锁。</p>
<pre><code>  即这些方法必须位于synchronize同步块内。
</code></pre>
</li>
<li><p>2）调用wait()方法后，线程状态由RUNNING变为WAITING，并将当前线程放置到对象的<br>等待队列。</p>
</li>
<li><p>3）notify()或notifyAll()方法调用后，等待线程依旧不会从wait()返回，需要调用notify()或<br>notifAll()的线程释放锁之后，等待线程才有机会从wait()返回。</p>
<pre><code>  即会将notify()或者notifAll()所在的同步块执行完才会调转到wait()所在的同步块。
</code></pre>
</li>
<li><p>4）notify()方法将等待队列中的一个等待线程从等待队列中移到同步队列中，而notifyAll()<br>方法则是将等待队列中所有的线程全部移到同步队列，被移动的线程状态由WAITING变为<br>BLOCKED。</p>
</li>
<li><p>5）从wait()方法返回的前提是获得了调用对象的锁。</p>
</li>
</ul>
<h3 id="管道输入-输出流"><a href="#管道输入-输出流" class="headerlink" title="管道输入&#x2F;输出流"></a>管道输入&#x2F;输出流</h3><p>管道流主要用于线程之间的数据传输，传输的媒介是内存。java中主要包括了4种具体的实现：PipedOutputStream、PipedInputStream、PipedReader和PipedWriter，前两种面向字节，而后两种面向字符。</p>
<pre><code>public class Piped &#123;

    public static void main(String[] args) throws Exception &#123;
        PipedWriter out = new PipedWriter();
        PipedReader in = new PipedReader();
        // 将输出流和输入流进行连接，否则在使用时会抛出IOException
        out.connect(in);

        Thread printThread = new Thread(new Print(in), &quot;PrintThread&quot;);
        printThread.start();
        int receive = 0;
        try &#123;
            while ((receive = System.in.read()) != -1) &#123;
                out.write(receive);
            &#125;
        &#125; finally &#123;
            out.close();
        &#125;
    &#125;

    static class Print implements Runnable &#123;
        private PipedReader in;

        public Print(PipedReader in) &#123;
            this.in = in;
        &#125;

        public void run() &#123;
            int receive = 0;
            try &#123;
                while ((receive = in.read()) != -1) &#123;
                    System.out.print((char) receive);
                &#125;
            &#125; catch (IOException ex) &#123;
            &#125;
        &#125;
    &#125;
&#125;
</code></pre>
<h3 id="join方法"><a href="#join方法" class="headerlink" title="join方法"></a>join方法</h3><ul>
<li><p>thread.join()当前线程等待thread线程终止后才继续执行。</p>
</li>
<li><p>thread.join(long millis)具备超时特性，在上者情况下，如果在指定时间内进程没终止，将从超时方法返回。</p>
</li>
<li><p>thread.join(long millis,int nanos) </p>
<pre><code>  public class Join &#123;
      public static void main(String[] args) throws Exception &#123;
          Thread previous = Thread.currentThread();
          for (int i = 0; i &lt; 10; i++) &#123;
              // 每个线程拥有前一个线程的引用，需要等待前一个线程终止，才能从等待中返回
              Thread thread = new Thread(new Domino(previous), String.valueOf(i));
              thread.start();
              previous = thread;
          &#125;
  
          TimeUnit.SECONDS.sleep(5);
          System.out.println(Thread.currentThread().getName() + &quot; terminate.&quot;);
      &#125;
  
      static class Domino implements Runnable &#123;
          private Thread thread;
  
          public Domino(Thread thread) &#123;
              this.thread = thread;
          &#125;
  
          public void run() &#123;
              try &#123;
                  thread.join();
              &#125; catch (InterruptedException e) &#123;
              &#125;
              System.out.println(Thread.currentThread().getName() + &quot; terminate.&quot;);
          &#125;
      &#125;
  &#125;
</code></pre>
</li>
</ul>
<p>结果如下：</p>
<pre><code>main terminate.
0 terminate.
1 terminate.
2 terminate.
3 terminate.
4 terminate.
5 terminate.
6 terminate.
7 terminate.
8 terminate.
9 terminate.
</code></pre>
<h3 id="ThreadLocal的使用"><a href="#ThreadLocal的使用" class="headerlink" title="ThreadLocal的使用"></a>ThreadLocal的使用</h3><p>ThreadLocal，即线程变量，是一个以ThreadLocal对象为键、任意对象为值的存储结构。这<br>个结构被附带在线程上，也就是说一个线程可以根据一个ThreadLocal对象查询到绑定在这个<br>线程上的一个值。</p>
<p>可以通过set(T)方法来设置一个值，在当前线程下再通过get()方法获取到原先设置的值。</p>
<pre><code>public class Profiler &#123;
    // 第一次get()方法调用时会进行初始化（如果set方法没有调用），每个线程会调用一次
    private static final ThreadLocal&lt;Long&gt; TIME_THREADLOCAL = new ThreadLocal&lt;Long&gt;() &#123;
         protected Long initialValue() &#123;
            return System.currentTimeMillis();&#125;
    &#125;;

    public static final void begin() &#123;
        TIME_THREADLOCAL.set(System.currentTimeMillis());
    &#125;

    public static final long end() &#123;
        return System.currentTimeMillis() - TIME_THREADLOCAL.get();
    &#125;

    public static void main(String[] args) throws Exception &#123;
        Profiler.begin();
        TimeUnit.SECONDS.sleep(1);
        System.out.println(&quot;Cost: &quot; + Profiler.end() + &quot; mills&quot;);
    &#125;
&#125;
</code></pre>
<hr>
<h2 id="java多线程基础"><a href="#java多线程基础" class="headerlink" title="java多线程基础"></a>java多线程基础</h2><h3 id="线程优先级"><a href="#线程优先级" class="headerlink" title="线程优先级"></a>线程优先级</h3><p>在Java线程中，通过一个整型成员变量priority来控制优先级，优先级的范围从1~10，在线<br>程构建的时候可以通过setPriority(int)方法来修改优先级，默认优先级是5，优先级高的线程分<br>配时间片的数量要多于优先级低的线程。设置线程优先级时，针对频繁阻塞（休眠或者I&#x2F;O操<br>作）的线程需要设置较高优先级，而偏重计算（需要较多CPU时间或者偏运算）的线程则设置较<br>低的优先级，确保处理器不会被独占。在不同的JVM以及操作系统上，线程规划会存在差异，<br>有些操作系统甚至会忽略对线程优先级的设定。</p>
<pre><code>setPriority(int)
</code></pre>
<h3 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h3><p>java线程在运行的生命周期可能处于下表的6中不同的状态，在给定的一个时刻，<br>线程只能处于其中的一个状态。</p>
<p><img src="https://raw.githubusercontent.com/BARKTEGH/MarkDownPhotos/master/multiThread/TIM%E6%88%AA%E5%9B%BE20181122170533.png"></p>
<p><img src="https://raw.githubusercontent.com/BARKTEGH/MarkDownPhotos/master/multiThread/TIM%E6%88%AA%E5%9B%BE20181122170707.png"></p>
<h3 id="守护线程Daemon"><a href="#守护线程Daemon" class="headerlink" title="守护线程Daemon"></a>守护线程Daemon</h3><p>Daemon线程是一种支持型线程，因为它主要被用作程序中后台调度以及支持性工作。这<br>意味着，当一个Java虚拟机中不存在非Daemon线程的时候，Java虚拟机将会退出。可以通过调<br>用Thread.setDaemon(true)将线程设置为Daemon线程。<br>Daemon线程被用作完成支持性工作，但是在Java虚拟机退出时Daemon线程中的finally块<br>并不一定会执行。</p>
<ul>
<li><em>Daemon属性需要在启动线程之前设置，不能在启动线程之后设置</em></li>
<li><em>在构建Daemon线程时，不能依靠finally块中的内容来确保执行关闭或清理资源的逻辑。</em></li>
</ul>
<h3 id="线程中断"><a href="#线程中断" class="headerlink" title="线程中断"></a>线程中断</h3><p>使用interrupt()方法来停止线程，但interrupt()方法仅仅是在当前线程中刚打了一个断点。</p>
<p>java提供两种方法判断线程是否中断：</p>
<blockquote>
<ul>
<li>this.interrupted()测试当前进程是否已经中断，执行后将具有状态标志清除为flase功能</li>
<li>this.isInterrupted()测试线程是否已经中断，不清除状态标志</li>
</ul>
</blockquote>
<p>推荐使用异常法来停止线程：</p>
<pre><code>public class MyThreadInterrupt extends Thread &#123;

    @Override
    public void run() &#123;
        super.run();
        try&#123;
            for(int i=0;i&lt;500000;i++)&#123;
                if(this.isInterrupted())&#123;
                    System.out.println(&quot;线程终止，即将退出&quot;);
                    throw new InterruptedException();
                &#125;
                System.out.println(&quot;i=&quot;+(i+1));
            &#125;
            System.out.println(&quot;for循环完了，继续执行程序。。。&quot;);
        &#125;catch (InterruptedException e)&#123;
            System.out.println(&quot;进入catch捕捉异常&quot;);
            e.printStackTrace();
        &#125;
    &#125;
&#125;
</code></pre>
<p>测试代码：</p>
<pre><code>@Test
public void test3()&#123;
    try&#123;
        MyThreadInterrupt myThreadInterrupt = new MyThreadInterrupt();
        myThreadInterrupt.start();
        Thread.sleep(2000);
        myThreadInterrupt.interrupt();
    &#125; catch (InterruptedException e)&#123;
        System.out.println(&quot;mian catch&quot;);
        e.printStackTrace();
    &#125;

&#125;
</code></pre>
<p><strong>如果不使用抛异常来终止线程，那么线程即使中断还是会for循环继续运行</strong></p>
<p>或者使用标志位来控制是否需要停止任务并终止线程</p>
<pre><code>public class Shutdown &#123;
    public static void main(String[] args) throws Exception &#123;
        Runner one = new Runner();
        Thread countThread = new Thread(one, &quot;CountThread&quot;);
        countThread.start();
        // 睡眠1秒，main线程对CountThread进行中断，使CountThread能够感知中断而结束
        TimeUnit.SECONDS.sleep(1);
        countThread.interrupt();
        Runner two = new Runner();
        countThread = new Thread(two, &quot;CountThread&quot;);
        countThread.start();
        // 睡眠1秒，main线程对Runner two进行取消，使CountThread能够感知on为false而结束
        TimeUnit.SECONDS.sleep(1);
        two.cancel();
    &#125;

    private static class Runner implements Runnable &#123;
        private long             i;

        private volatile boolean on = true;

        @Override
        public void run() &#123;
            while (on &amp;&amp; !Thread.currentThread().isInterrupted()) &#123;
                i++;
            &#125;
            System.out.println(&quot;Count i = &quot; + i);
        &#125;

        public void cancel() &#123;
            on = false;
        &#125;
    &#125;
&#125;
</code></pre>
<blockquote>
<p>注意： suspend(),resume(),stop()已过期</p>
</blockquote>
<blockquote>
<p>全文来自 java并发编程的艺术 和 java多线程编程核心技术</p>
</blockquote>

      
    </div>

    
    
    

    <footer class="post-footer">
        <div class="post-eof"></div>
      
    </footer>
  </article>
</div>




  <nav class="pagination">
    <a class="extend prev" rel="prev" title="上一页" aria-label="上一页" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span>
  </nav>

</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">

  <div class="copyright">
    &copy; 
    <span itemprop="copyrightYear">2025</span>
    <span class="with-love">
      <i class="fa fa-heart"></i>
    </span>
    <span class="author" itemprop="copyrightHolder">三十而立</span>
  </div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">61k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">3:40</span>
  </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>
  <div class="sidebar-dimmer"></div>
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up fa-lg"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>

</body>
</html>
